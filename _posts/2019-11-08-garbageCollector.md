---
layout: post
title: Java 垃圾收集器
date: 2019-11-08
tags: JVM
---

## [**GC算法**](../../../2019/11/garbageCollectorAlgorithm/)
<br />

### **垃圾收集器**

垃圾收集算法的具体实现，包含所有的收集器如下图

![](/images/posts/gc/a4.png)

7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用,虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器

#### 1、Serial收集器

是一个单线程**新生代**收集器，在进行垃圾收集时，会暂停其他所有的工作线程，直到它收集结束，工作过程如下

![](/images/posts/gc/a1.png)

与其他收集器的**单线程**相比，优点是简单高效，对于**限定单个CPU**的环境，没有线程交互的开销，常用于运行在Client模式下的虚拟机

#### 2、ParNew收集器

是Serial收集器的多线程版本，其他实现上完全一样，工作过程如下图

![](/images/posts/gc/a2.png)

是许多运行在Server模式下的虚拟机的首选的**新生代**收集器，目前除了Serial收集器，只有它能和CMS收集器配合工作，
ParNew收集器由于有线程交互的开销，在单CPU的环境中没有Serial收集器效果好，即使在两个CPU的环境中，通过超线程技术，
都不能百分之百地保证可以超越Serial收集器。但是随着CPU的个数增加，可以有效的利用系统资源，它默认开启的收集线程数与CPU的数量相同，
在CPU非常多的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数

并发和并行区别

+ 并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态

+ 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上

#### 3、Parallel Scavenge收集器

是一个**新生代**使用**复制算法**的**并行多线程**收集器，目标是达到一个可控制的吞吐量

>吞吐量：（CPU用于运行用户代码的时间与CPU总消耗时间的比值，
>即吞吐量 = 运行用户代码时间 /（运行用户代码时间 +垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%）
>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，
>主要适合在后台运算而不需要太多交互的任务。

提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的```-XX:MaxGCPauseMillis```参数以及直接设置吞吐量大小的```-XX:GCTimeRatio```参数，
以及```-XX:+UseAdaptiveSizePolicy```参数开启自适应调节策略

+ MaxGCPauseMillis：一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值

+ GCTimeRatio：一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。
如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。

+ UseAdaptiveSizePolicy；当这个参数打开之后，就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、
晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，
动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量

#### 4、Serial Old收集器

是Serial收集器的老年代版本，是一个单线程收集器，使用“标记-整理”算法，主要在Client模式下虚拟机使用。如果在Server模式下，主要有两大用途

+ 在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使

+ 作为CMS收集器的后备预案，在并发收集发生Concurrent ModeFailure时使用

工作过程如下

![](/images/posts/gc/a3.png)

#### 5、Parallel Old收集器

是Parallel Scavenge收集器的**老年代**版本，使用多线程和“标记-整理”算法，在注重吞吐量以及CPU资源敏感的场合，可以优先考虑Parallel Scavenge
加Parallel Old收集器

工作过程如下

![](/images/posts/gc/a5.png)

#### 6、CMS收集器

CMS（Concurrent Mark Sweep）收集器是基于”标记-清除“算法实现的，一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，
这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。

整个过程分为4个步骤

+ 初始标记（CMS initial mark）

+ 并发标记（CMS concurrent mark）

+ 重新标记（CMS remark）

+ 并发清除（CMS concurrent sweep）

初始标记、重新标记这两个步骤仍然需要“Stop The World”，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，
并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，
这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。

工作过程如下

![](/images/posts/gc/a6.png)

主要优点是并发收集，低停顿

缺点有以下三点

+ 对CPU资源非常敏感，在并发阶段，虽然不会让用户线程停顿，但会占用一部分CPU资源导致应用程序变慢，吞吐量降低，默认启动的回收线程是（CPU数量+3）/ 4

+ 无法处理浮动垃圾，可能出现“Concurrent ModeFailure”失败而导致另一次Full GC的产生，由于CMS并发清理阶段用户线程还在运行着，
伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉，
这一部分垃圾就称为“浮动垃圾”，由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，
因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用，
可通过参数```-XX:CMSInitiatingOccupancyFraction```的值来设定触发百分比，如果因为内存空间不足导致“Concurrent Mode Failure”，
这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了

+ 基于“标记—清除”算法实现，会有大量内存空间碎片，所以提供了一个```-XX:+UseCMSCompactAtFullCollection```开关参数（默认就是开启的），
用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长，
另外一个参数```-XX:CMSFullGCsBeforeCompaction```，是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）

#### 7、G1收集器

G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，是一款面向服务端应用的垃圾收集器，与其他GC收集器相比，G1具备如下特点

+ 并行与并发：能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop The World停顿的时间，
部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行

+ 分代收集：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果

+ 空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，
这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存

+ 可预测的停顿：这是G1相对于CMS的另一大优势，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，
消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。

在G1之前的其他收集器进行收集的范围都是整个新生代或者老年代，而使用G1收集器时，它将整个Java堆划分为多个大小相等的独立区域（Region），
新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合

G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集，
G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，
优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，
保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。

G1收集器把堆分成多个Region后，一个对象分配在某Region中，可能会被其他Region中的对象引用，在做可达性判断对象是否存活的时候，为了不扫描整个堆，
在每个Region中都有一个Remembere Set，当有对Reference类型的数据进行写操作时，会产生一个Write Barrier暂时中断写操作，
检查Reference引用的对象是否处于不同的Region之中（在分代的例子中就是检查是否老年代中的对象引用了新生代中的对象），如果是，
便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set之中，当进行内存回收时，
在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏。

G1收集器的运作大致可划分为以下几个步骤（不计算维护Remember Set操作）

+ 初始标记（Initial Marking）

+ 并发标记（Concurrent Marking）

+ 最终标记（Final Marking）

+ 筛选回收（Live Data Counting and Evacuation）

初始标记阶段仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，
能在正确可用的Region中创建新对象，这阶段需要停顿线程，但耗时很短。并发标记阶段是从GC Root开始对堆中对象进行可达性分析，找出存活的对象，
这阶段耗时较长，但可与用户程序并发执行。最终标记阶段则是为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，
虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，
这阶段需要停顿线程，但是可并行执行。最后在筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，
可以做到与用户程序一起并发执行，只回收一部分Region，时间是用户可控制的，停顿用户线程将大幅提高收集效率

工作过程如下图

![](/images/posts/gc/a7.png)


#### 8、垃圾收集器相关参数

![](/images/posts/gc/a8.png)

### **内存分配和回收策略**

对象的内存分配主要是在堆上分配，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，
少数情况下也可能会直接分配在老年代中，分配的规则取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。

#### 1、对象优先在Eden上分配

大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。

可通过```-XX:+PrintGCDetails```这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。

Minor GC和Full GC区别

+ 新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快

+ 老年代GC（Major GC / Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，
在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

#### 2、大对象直接进入老年代

需要大量连续内存空间的Java对象，比如很长的字符串以及数组。对于Java虚拟机来说，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，
写程序的时候应当避免，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们

可通过```-XX:PretenureSizeThreshold```参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制

#### 3、长期存活的对象将进入老年代

虚拟机采用了分代收集的思想来管理内存，内存回收时必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这点，
虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，
将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），
就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数```-XX:MaxTenuringThreshold```设置。


#### 4、动态对象年龄判定

如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

#### 5、空间分配担保

由于新生代采用复制算法，为了内存的利用率，只使用一个Survivor空间作为轮换，但当进行一次Minor GC之后仍有大量对象存活，极端情况下新生代中的
所有对象都存活，就需要老年代有足够的空间做分配担保，把Survivor无法容纳的对象直接进入老年代，确保程序能正常为新对象分配内存空间  

所以在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立即可以做担保，那么Minor GC可以确保是安全的。
如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，
如果大于，将尝试着进行一次MinorGC，如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC


