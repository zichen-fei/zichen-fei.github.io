---
layout: post
title: 转：从B树、B+树、B*树谈到R 树
date: 2017-08-15
tags: B-Tree
---

<div id="article_content" class="article_content tracking-ad" data-mod="popu_307" data-dsm="post">
<p class="MsoNormal" style="PADDING-LEFT: 180px; MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left"><span style="mso-bidi-font-weight: normal"><span style="font-family:微软雅黑;FONT-SIZE: 14pt; mso-ascii-font-family: Verdana"><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: center" align="center"><span style="mso-bidi-font-weight: normal"><span lang="EN-US" style="FONT-SIZE: 12pt">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">作者：</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">July</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">、weedge、</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">Frankie</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">。编程艺术室出品。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">说明：本文从</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树开始谈起，然后论述</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">B+树、B*</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树，最后谈到</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">R </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树。其中</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树、</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">B+</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树及B*树部分由weedge完成，</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">R </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树部分由</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">Frankie</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">完成，全文最终由</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">July</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">统稿修订完成。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">出处：<a target="_blank" href="http://blog.csdn.net/v_JULY_v"><strong><span style="color:#002d93;">http://blog.csdn.net/v_JULY_v</span>&nbsp;</strong></a></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span lang="EN-US" style="mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><h2><a name="t0" target="_blank"></a><span style="mso-bidi-font-weight: normal"><strong><span style="font-family:微软雅黑;FONT-SIZE: 14pt; mso-ascii-font-family: Verdana">第一节、</span><span lang="EN-US" style="FONT-SIZE: 14pt">B</span><span style="font-family:微软雅黑;FONT-SIZE: 14pt; mso-ascii-font-family: Verdana">树、</span><span lang="EN-US" style="FONT-SIZE: 14pt">B+</span><span style="font-family:微软雅黑;FONT-SIZE: 14pt; mso-ascii-font-family: Verdana">树、B*树</span></strong></span></h2><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 13px"><strong><span style="font-family:Verdana;mso-bidi-font-size: 10.5pt">1.</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana">前言：</span></strong></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px">动态查找树主要有：二叉查找树（Binary Search Tree），平衡二叉查找树（Balanced Binary Search Tree），<a target="_blank" href="http://blog.csdn.net/v_JULY_v/category/774945.aspx">红黑树</a>(Red-Black Tree )，B-tree/<a target="_blank" name="OLE_LINK1">B<sup>+</sup>-tree/ B<sup>*</sup>-tree </a>(B~Tree)。前三者是典型的二叉查找树结构，其查找的时间复杂度<span style="font-family:'Times New Roman';"><span class="texhtml"><em><span lang="EN" style="mso-bidi-font-size: 10.5pt; mso-ansi-font-size: 10.5pt; mso-ansi-language: EN">O</span></em></span><span class="texhtml"><span lang="EN" style="mso-bidi-font-size: 10.5pt; mso-ansi-font-size: 10.5pt; mso-ansi-language: EN">(log<sub>2</sub><em>N</em>)</span></span></span>与树的深度相关，那么降低树的深度自然会提高查找效率。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px">但是咱们有面对这样一个实际问题：就是大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于<strong>树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下</strong>（为什么会出现这种情况，待会在外部存储器-磁盘中有所解释），那么如何减少树的深度（当然是不能减少查询的数据量），一个基本的想法就是：采用<strong>多叉树</strong>结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px">也就是说，因为磁盘的操作费时费资源，如果过于频繁的多次查找势必效率低下。那么如何提高效率，即如何避免磁盘过于频繁的多次查找呢？根据磁盘查找存取的次数往往由树的高度所决定，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，那么是不是便能有效减少磁盘查找存取的次数呢？那这种有效的树结构是一种怎样的树呢？</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px">这样我们就提出了一个新的查找树结构——多路查找树。根据平衡二叉树的启发，自然就想到平衡多路查找树结构，也就是这篇文章所要阐述的第一个主题<strong>B~tree，</strong>即B树结构(后面，我们将看到，B树的各种操作能使B树保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率)。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><strong>B-tree（B-tree树即B树</strong>，B即Balanced，平衡的意思<strong>）这棵神奇的树是在</strong><span style="font-family:Arial;color:black;mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt"><a target="_blank" href="http://academic.research.microsoft.com/Author/1008233/rudolf-bayer"><span style="color:#0044cc;">Rudolf Bayer</span></a>,&nbsp;<a target="_blank" href="http://academic.research.microsoft.com/Author/3077370/edward-m-mccreight"><span style="color:#0044cc;">Edward M. McCreight</span></a>(1970)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Arial; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Arial; mso-font-kerning: 0pt; mso-bidi-font-family: Arial">写的一篇论文《</span></span><a target="_blank" name="OLE_LINK9"><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial"><span style="FONT-SIZE: 13px">Organization and Maintenance of Large Ordered Indices</span></span></a><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Georgia; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia; mso-bidi-font-family: Arial">》中首次提出的（</span><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial">wikipedia</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Georgia; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia; mso-bidi-font-family: Arial">中：</span><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial"><span style="color:#0044cc;"><a target="_blank" href="http://en.wikipedia.org/wiki/B-tree"><span style="color:#002d93;">http://en.wikipedia.org/wiki/B-tree</span></a></span></span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Georgia; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia; mso-bidi-font-family: Arial">，阐述了</span><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial">B-tree</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Georgia; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia; mso-bidi-font-family: Arial">名字来源以及相关的开源地址）。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Georgia; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia; mso-bidi-font-family: Arial">在开始介绍</span><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial">B~tree</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Georgia; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia; mso-bidi-font-family: Arial">之前，先了解下相关的硬件知识，才能很好的了解为什么需要</span><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial">B~tree</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Georgia; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia; mso-bidi-font-family: Arial">这种外存数据结构。</span></span><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Arial"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 13px"><strong><span style="color:black;mso-bidi-font-size: 10.5pt">2.</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">外存储器</span><span style="color:black;mso-bidi-font-size: 10.5pt">—</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">磁盘</span></strong><span style="color:black;mso-bidi-font-size: 10.5pt"> </span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">计算机存储设备一般分为两种</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">：</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">内存储器</span><span style="color:black;mso-bidi-font-size: 10.5pt">(main memory)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">和外存储器</span><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">(external memory)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。</span><span style="color:black;mso-bidi-font-size: 10.5pt"> </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">内存存取速度快，但容量小，价格昂贵，而且不能长期保存数据</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">在不通电情况下数据会消失</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">外存储器—磁盘是一种直接存取的存储设备</span><span style="color:black;mso-bidi-font-size: 10.5pt">(DASD)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。它是以存取时间变化不大为特征的。可以直接存取任何字符组，且容量大、速度较其它外存设备更快。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><strong><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">2.1</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">磁盘的构造</span><span style="color:black;mso-bidi-font-size: 10.5pt"></span></strong></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">磁盘是一个扁平的圆盘</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">与电唱机的唱片类似</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图11.3中所示的</span><span style="color:black;mso-bidi-font-size: 10.5pt">6</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有</span><span style="color:black;mso-bidi-font-size: 10.5pt">10</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">个面可以用来保存信息。</span></span></p><p class="MsoNormal" style="PADDING-LEFT: 60px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px"><img height="433" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_13074405911zG7.jpg" width="233">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">当磁盘驱动器执行读</span><span style="color:black;mso-bidi-font-size: 10.5pt">/</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读</span><span style="color:black;mso-bidi-font-size: 10.5pt">/</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">写头</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">又叫磁头</span><span style="color:black;mso-bidi-font-size: 10.5pt">) </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">下通过时，就可以进行数据的读</span><span style="color:black;mso-bidi-font-size: 10.5pt"> / </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">写了。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">一般磁盘分为固定头盘</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">磁头固定</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读</span><span style="color:black;mso-bidi-font-size: 10.5pt">/</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">写。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">活动头盘</span><span style="color:black;mso-bidi-font-size: 10.5pt"> (</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">如上图</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">的磁头是可移动的。每一个盘面上只有一个磁头</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">磁头是双向的，因此正反盘面都能读写</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">行动整齐划一</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面</span><span style="color:black;mso-bidi-font-size: 10.5pt"> </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。因此，柱面的个数也就是盘面上的磁道数。</span></span><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><strong><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">2.2</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">磁盘的读</span><span style="color:black;mso-bidi-font-size: 10.5pt">/</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">写原理和效率</span><span style="color:black;mso-bidi-font-size: 10.5pt"> </span></strong></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">磁盘上数据必须用一个三维地址唯一标示：柱面号、盘面号、块号</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">磁道上的盘块</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。</span><span style="color:black;mso-bidi-font-size: 10.5pt"> </span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">读</span><span style="color:black;mso-bidi-font-size: 10.5pt">/</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">写磁盘上某一指定数据需要下面</span><span style="color:black;mso-bidi-font-size: 10.5pt">3</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">个步骤：</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">(1)&nbsp; </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">首先移动臂根据柱面号使磁头移动到所需要的柱面上，这一过程被称为定位或查找</span><span style="color:black;mso-bidi-font-size: 10.5pt"> </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">(2)&nbsp; </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">如上图11.3中所示的</span><span style="color:black;mso-bidi-font-size: 10.5pt">6</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">盘组示意图中，所有磁头都定位到了</span><span style="color:black;mso-bidi-font-size: 10.5pt">10</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">个盘面的</span><span style="color:black;mso-bidi-font-size: 10.5pt">10</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">条磁道上</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">磁头都是双向的</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。这时根据盘面号来确定指定盘面上的磁道。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">(3) </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">盘面确定以后，盘片开始旋转，将指定块号的磁道段移动至磁头下。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">经过上面三个步骤，指定数据的存储位置就被找到。这时就可以开始读</span><span style="color:black;mso-bidi-font-size: 10.5pt">/</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">写操作了。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">访问某一具体信息，由</span><span style="color:black;mso-bidi-font-size: 10.5pt">3</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">部分时间组成：</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">● </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">查找时间</span><span style="color:black;mso-bidi-font-size: 10.5pt">(seek time) Ts: </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">完成上述步骤</span><span style="color:black;mso-bidi-font-size: 10.5pt">(1)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">所需要的时间。这部分时间代价最高，最大可达到</span><span style="color:black;mso-bidi-font-size: 10.5pt">0.1s</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">左右。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">● </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">等待时间</span><span style="color:black;mso-bidi-font-size: 10.5pt">(latency time) Tl: </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">完成上述步骤</span><span style="color:black;mso-bidi-font-size: 10.5pt">(3)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">所需要的时间。由于盘片绕主轴旋转速度很快，一般为</span><span style="font-family:Georgia;color:black;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">7200</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">转</span><span style="color:black;mso-bidi-font-size: 10.5pt">/</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">分</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">电脑硬盘的性能指标之一</span><span style="color:black;mso-bidi-font-size: 10.5pt">, </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">家用的普通硬盘的转速一般有</span><span style="color:black;mso-bidi-font-size: 10.5pt">5400rpm(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">笔记本</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">、</span><span style="color:black;mso-bidi-font-size: 10.5pt">7200rpm</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">几种</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">。</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">因此一般旋转一圈大约</span><span style="color:black;mso-bidi-font-size: 10.5pt">0.0083s</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">● </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">传输时间</span><span style="color:black;mso-bidi-font-size: 10.5pt">(transmission time) Tt: </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">数据通过系统总线传送到内存的时间，一般传输一个字节</span><span style="color:black;mso-bidi-font-size: 10.5pt">(byte)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">大概</span><span style="color:black;mso-bidi-font-size: 10.5pt">0.02us=2*10^(-8)s</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><strong>磁盘读取数据是以盘块</strong><span lang="EN-US" style="mso-bidi-font-weight: bold; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">(block)</span><strong>为基本单位的。</strong><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">位于同一盘块中的所有数据都能被一次性全部读取出来。而磁盘</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">IO</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">代价主要花费在查找时间</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">Ts</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Georgia">上。因此<span style="mso-bidi-font-weight: bold">我们应该尽量将相关信息存放在同一盘块，同一磁道中。或者至少放在同一柱面或相邻柱面上，以求在读</span></span><span lang="EN-US" style="mso-bidi-font-weight: bold; mso-bidi-font-size: 10.5pt">/</span><strong>写信息时尽量减少磁头来回移动的次数，避免过多的查找时间</strong><span lang="EN-US" style="mso-bidi-font-weight: bold; mso-bidi-font-size: 10.5pt">Ts</span><strong>。</strong></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">所以，在大规模数据存储方面，大量数据存储在外存磁盘中，而在外存磁盘中读取</span><span style="color:black;mso-bidi-font-size: 10.5pt">/</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">写入块</span><span style="color:black;mso-bidi-font-size: 10.5pt">(block)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">中某数据时，首先需要定位到磁盘中的某块，如何有效地查找磁盘中的数据，需要一种合理高效的外存数据结构，就是下面所要重点阐述的</span><span style="color:black;mso-bidi-font-size: 10.5pt">B-tree</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">结构，以及相关的变种结构：</span><strong><strong>B<sup>+</sup>-tree结构和B<sup>*</sup>-tree结构。</strong></strong></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><strong></strong></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><strong></strong></p><p><a target="_blank" name="OLE_LINK2"><strong><span style="font-family:宋体;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体; mso-fareast-font-family: 微软雅黑"><span style="FONT-SIZE: 13px">3.</span></span></strong></a><span style="FONT-SIZE: 13px"><span style="mso-bookmark: OLE_LINK2"><strong><span style="font-family:Verdana;mso-bidi-font-size: 10.5pt">B- 树</span></strong></span></span>&nbsp;</p><p>&nbsp; &nbsp; &nbsp;<span style="font-family:SimHei;"><span style="font-family:微软雅黑;FONT-SIZE: 13px; TEXT-INDENT: 28px"><strong>3.1什么是B-树</strong></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-WEIGHT: bold"><span lang="EN-US" style="FONT-WEIGHT: normal; FONT-FAMILY: 宋体; mso-bidi-font-weight: bold; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体; mso-fareast-font-family: 微软雅黑"><span style="FONT-SIZE: 13px">具体讲解之前，<span style="TEXT-DECORATION: underline">有一点，再次强调下：B-树，即为B树</span>。因为B树的原英文名称为B-tree，而国内很多人喜欢把B-tree译作B-树，其实，这是个非常不好的直译，很容易让人产生误解。如人们可能会以为B-树是一种树，而B树又是一种一种树。而事实上是，<span style="TEXT-DECORATION: underline"><span style="color:#000000;"><strong>B-tree就是指的B树</strong></span></span>。特此说明。</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px">我们知道，B 树是为了磁盘或其它存储设备而设计的一种多叉（下面你会看到，相对于二叉，B树每个内结点有多个分支，即多叉）平衡查找树。与本blog之前介绍的红黑树很相似，但在降低磁盘I/0操作方面要更好一些。许多数据库系统都一般使用B树或者B树的各种变形结构，如下文即将要介绍的B+树，B*树来存储信息。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px">&nbsp;B树与红黑树最大的不同在于，B树的结点可以有许多子女，从几个到几千个。那为什么又说B树与红黑树很相似呢?因为与红黑树一样，一棵含n个结点的B树的高度也为O（lgn），但可能比一棵红黑树的高度小许多，应为它的分支因子比较大。所以，B树可以在O（logn）时间内，实现各种如插入（insert），删除（delete）等动态集合操作。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px">如下图所示，即是一棵B树，一棵关键字为英语中辅音字母的B树，现在要从树种查找字母R（包含n[x]个关键字的内结点x，x有n[x]+1]个子女（也就是说，一个内结点x若含有n[x]个关键字，那么x将含有n[x]+1个子女）。所有的叶结点都处于相同的深度，带阴影的结点为查找字母R时要检查的结点）：</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><strong><strong><span style="FONT-SIZE: 13px"><img height="187" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_130745821166Sc.jpg" width="612"></span></strong></strong>&nbsp;</p><div><p><strong><strong><span style="FONT-SIZE: 13px">相信，从上图你能轻易的看到，一个内结点x若含有n[x]个关键字，那么x将含有n[x]+1个子女。如含有2个关键字<span style="TEXT-DECORATION: underline">D H</span>的内结点有3个子女，而含有3个关键字<span style="TEXT-DECORATION: underline">Q T X</span>的内结点有4个子女。</span></strong></strong></p><p>&nbsp; &nbsp; B树的定义，从下文中，你将看到，或者是用阶，或者是用度，如下段文字所述：<br><span style="font-size:12px;">&nbsp; <span style="font-family:Comic Sans MS;">&nbsp; Unfortunately, the literature on B-trees is not uniform in its use of terms relating to B-Trees. (Folk &amp; Zoellick 1992, p. 362)&nbsp;Bayer &amp; McCreight (1972), Comer (1979), and others define the order of B-tree as the minimum number of keys in a non-root node. Folk &amp; Zoellick (1992) points out that terminology is ambiguous because the maximum number of keys is not clear. An order 3 B-tree might hold a maximum of 6 keys or a maximum of 7 keys. (Knuth 1998,TAOCP p. 483) avoids the problem by defining the order to be maximum number of children (which is one more than the maximum number of keys).</span></span></p></div><blockquote style="margin: 0 0 0 40px; border: none; padding: 0px;"><div><p><span style="font-size:12px;"><span style="font-family:Comic Sans MS;"><img src="http://img.blog.csdn.net/20140305131309171" alt=""></span></span></p></div></blockquote><div><p>&nbsp;<span style="font-family: 'Comic Sans MS'; "> &nbsp; from: </span><a target="_blank" href="http://en.wikipedia.org/wiki/Btree#Technical_description"><span style="font-size: 12px; "><span style="font-family:Comic Sans MS;">ht</span></span><span style="font-family:Comic Sans MS;font-size:12px;">tp://en.wikipedia.org/wiki/Btree#Technical_description</span></a>。</p><p><span style="font-family:Microsoft YaHei;">&nbsp; &nbsp; </span><span style="font-family:Arial Black;">用阶定义的B树</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">&nbsp; &nbsp; B </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树又叫平衡多路查找树。<span style="color:#333333;"><strong>一棵</strong></span></span><span style="COLOR: #333333"><span style="FONT-WEIGHT: bold"><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">m</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">阶的</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">B </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt"> (</span><span style="COLOR: rgb(51,51,51); LINE-HEIGHT: 18px; FONT-FAMILY: Verdana"><span style="font-size:12px;"><span lang="EN-US"><span style="FONT-WEIGHT: normal">注：切勿简单的认为一棵m阶的B树是m</span></span><span style="font-family:微软雅黑;"><span style="FONT-WEIGHT: normal">叉树，虽然存在</span><a target="_blank" href="http://zh.wikipedia.org/wiki/%E5%9B%9B%E5%8F%89%E6%A0%91"><span style="FONT-WEIGHT: normal">四叉树</span></a>，<a target="_blank" href="http://zh.wikipedia.org/wiki/%E5%85%AB%E5%8F%89%E6%A0%91"><span style="FONT-WEIGHT: normal">八叉树</span></a>，<span style="FONT-WEIGHT: normal"><a target="_blank" href="http://blog.csdn.net/v_july_v/article/details/8203674">KD</a></span><span style="FONT-WEIGHT: normal"><a target="_blank" href="http://blog.csdn.net/v_july_v/article/details/8203674">树</a>，及vp/R树/R*树/R+树/X树/M树/线段树/希尔伯特R树/优先R树等空间划分树，但与B树完全不等同</span></span></span></span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">)</span></span></span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt"><span style="color:#333333;"><strong>的特性如下</strong></span>：</span><span style="color:black;mso-bidi-font-size: 10.5pt"> </span></span></p><ol><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 12.5pt; COLOR: #000000; FONT-FAMILY: 'Verdana'; mso-spacerun: 'yes'"><span style="FONT-FAMILY: 宋体"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="font-family:Verdana;">树中每个结点最多含有m个孩子（m&gt;=2）；</span></span></span></span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（<span style="font-family:'宋体';color:#000000;FONT-SIZE: 12pt; mso-spacerun: 'yes'">其中ceil(x)是一个取上限的函数</span>）； </span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）； </span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)；（<u>读者反馈@冷岳</u>：<span style="font-family:Arial, songti, 宋体, sumsun, sans-serif;color:#454545;FONT-SIZE: 13px; LINE-HEIGHT: 13px">这里有错，叶子节点只是没有孩子和指向孩子的指针，这些节点也存在，也有元素。@研究者July：其实，关键是把什么当做叶子结点，因为如红黑树中，每一个NULL指针即当做叶子结点，只是没画出来而已</span>）。</span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;a)&nbsp;&nbsp; Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。 <br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;b)&nbsp;&nbsp; Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c)&nbsp;&nbsp; 关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1。</span></span><span style="FONT-SIZE: 13px">如下图所示：</span></div></li></ol></div><div><p class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><img alt="" src="http://hi.csdn.net/attachment/201112/18/0_1324205685teT7.gif"><br></span></p><p class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><span style="font-family:Microsoft YaHei;">&nbsp; &nbsp;&nbsp;</span><span style="font-family:Arial Black;">用度定义的B树</span></span></p><p class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="color: black; "><span style="font-size:12px;">&nbsp; &nbsp; &nbsp; 针对上面的5点，再阐述下：B树中每一个结点能包含的关键字（如之前上面的<span style="font-family: 宋体; "><span style="TEXT-DECORATION: underline">D H</span>和<span style="TEXT-DECORATION: underline">Q T X</span></span>）数有一个上界和下界。这个下界可以用一个称作B树的最小度数（算法导论中文版上译作度数，<span style="font-family: Arial, songti, 宋体, sumsun, sans-serif; color: rgb(69, 69, 69); line-height: 13px; ">最小度数即内节点中节点最小孩子数目</span>）m（m&gt;=2）表示。</span></span></p><ul><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="font-size:12px;">每个非根的内结点至多有m个子女，每个非根的结点必须至少含有m-1个关键字，如果树是非空的，则根结点至少包含一个关键字；</span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="font-size:12px;">每个结点可包含至多2m-1个关键字。所以一个内结点至多可有2m个子女。如果一个结点恰好有2m-1个关键字，我们就说这个结点是满的（<span style="color:#333333;">而稍后介绍的B*树作为B树的一种常用变形，B*树中要求每个内结点至少为2/3满，而不是像这里的B树所要求的至少半满</span>）；</span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="color: black; "><span style="text-decoration: underline; ">当关键字数m=2（t=2的意思是，<span style="font-size:14px;">m</span></span></span><span lang="EN-US" style="font-size: 12px; color: black; "><u><span><span style="color:#888888;">min</span></span>=2，m可以&gt;=2）时的B树是最简单的</u><span style="color: rgb(51, 51, 51); "><strong>（</strong>有很多人会因此误认为B树就是二叉查找树，但二叉查找树就是二叉查找树，B树就是B树，B树是一棵含有m（m&gt;=2）个关键字的平衡多路查找树<strong>）</strong>，此时，</span>每个内结点可能因此而含有2个、3个或4个子女，亦即一棵2-3-4树，然而在实际中，通常采用大得多的t值。</span></div></li></ul><p><span style="font-size: 12px; ">&nbsp; &nbsp; B树中的每个结点根据实际情况可以包含大量的关键字信息和分支(当然是不能超过磁盘块的大小，根据磁盘驱动(disk drives)的不同，一般块的大小在1k~4k左右)；这样树的深度降低了，这就意味着查找一个元素只要很少结点从外存磁盘中读入内存，很快访问到要查找的数据。如果你看完上面关于B树定义的介绍，思维感觉不够清晰，请<span style="color:#660000;">继续参阅下文第</span><span style="font-size: 13px; "><span style="color:#660000;">6小节、B树的插入、删除操作 部分</span>。</span></span></p><p><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="font-family:Comic Sans MS;"><span style="font-family:微软雅黑;FONT-SIZE: 13px; TEXT-INDENT: 28px"><strong>&nbsp; &nbsp; 3.2B树的类型和节点定义</strong></span></span></span></span></p><p><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">&nbsp; &nbsp; B树的类型和节点定义如下图所示：</span></span></p><p><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><img height="400" alt="" src="http://hi.csdn.net/attachment/201112/18/0_1324205934vx2N.gif" width="700"></span></span></p><p>&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><img height="300" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_13074405906V6Q.jpg" width="624"></span></span></p><p><span style="font-family:Comic Sans MS;"><span style="font-family:微软雅黑;FONT-SIZE: 13px; TEXT-INDENT: 28px"><strong>&nbsp; &nbsp; 3.3文件查找的具体过程(</strong>涉及磁盘IO操作<strong>)</strong></span></span></p><p style="TEXT-INDENT: 21pt"><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">为了简单，这里用少量数据构造一棵3叉树的形式，实际应用中的</span></span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">B</span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">树结点中关键字很多的。上面的图中比如根结点，其中</span></span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">17表示一个磁盘</span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">文件的文件名；小红方块表示这个17文件内容在硬盘中的存储位置；p1表示指向</span></span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">17</span><span style="font-family:宋体;"><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">左子树的指针。</span></span></p><p><span style="font-family:宋体;"><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">其结构可以简单定义为：</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-ALIGN: left; mso-para-margin-left: 2.0gd; mso-layout-grid-align: none" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:新宋体;color:blue;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes">typedef</span><span style="font-family:新宋体;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes"> <span style="color:blue;">struct</span> {</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-ALIGN: left; mso-para-margin-left: 2.0gd; mso-layout-grid-align: none" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:新宋体;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="color:green;">/*</span></span><span style="font-family:新宋体;color:green;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes">文件数<span lang="EN-US">*/</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-ALIGN: left; mso-para-margin-left: 2.0gd; mso-layout-grid-align: none" align="left"><span style="font-family:新宋体;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes"><span style="FONT-SIZE: 13px"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="color:blue;">int</span><span style="mso-spacerun: yes">&nbsp; </span>file_num;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-ALIGN: left; mso-para-margin-left: 2.0gd; mso-layout-grid-align: none" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:新宋体;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="color:green;">/*</span></span><span style="font-family:新宋体;color:green;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes">文件名<span lang="EN-US">(key)*/</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-ALIGN: left; mso-para-margin-left: 2.0gd; mso-layout-grid-align: none" align="left"><span style="font-family:新宋体;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes"><span style="FONT-SIZE: 13px"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="color:blue;">char</span> * file_name[max_file_num];</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-ALIGN: left; mso-para-margin-left: 2.0gd; mso-layout-grid-align: none" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:新宋体;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp; </span><span style="color:green;">/*</span></span><span style="font-family:新宋体;color:green;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes">指向子节点的指针<span lang="EN-US">*/</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-ALIGN: left; mso-para-margin-left: 2.0gd; mso-layout-grid-align: none" align="left"><span style="font-family:新宋体;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes"><span style="FONT-SIZE: 13px"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>BTNode * BTptr[max_file_num+1];</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-ALIGN: left; mso-para-margin-left: 2.0gd; mso-layout-grid-align: none" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:新宋体;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="color:green;">/*</span></span><span style="font-family:新宋体;color:green;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes">文件在硬盘中的存储位置<span lang="EN-US">*/</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-ALIGN: left; mso-para-margin-left: 2.0gd; mso-layout-grid-align: none" align="left"><span style="font-family:新宋体;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: Verdana; mso-font-kerning: 0pt; mso-no-proof: yes"><span style="FONT-SIZE: 13px"><span style="mso-spacerun: yes">&nbsp;&nbsp;&nbsp;&nbsp; </span>FILE_HARD_ADDR offset[max_file_num];</span></span></p><p style="MARGIN-LEFT: 21pt; mso-para-margin-left: 2.0gd"><span style="font-family:新宋体;FONT-SIZE: 10.5pt; mso-hansi-font-family: 宋体; mso-no-proof: yes">}BTNode;</span></p><p style="TEXT-INDENT: 21pt"><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">假如每个盘块可以正好存放一个B树的结点（正好存放</span></span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">2</span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">个文件名）。那么一个BTNODE结点就代表一个盘块，而子树指针就是存放另外一个盘块</span></span><span style="font-family:宋体;"><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">的地址。</span></span></p><p style="TEXT-INDENT: 21pt"><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">下面，咱们来模拟下查找文件29的过程：</span></span></p><ol><li><div style="TEXT-INDENT: 21pt"><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">根据根结点指针找到文件目录的根磁盘块1，将其中的信息导入内存。【磁盘</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">IO</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">操作 1次】</span><span style="font-family:宋体;color:black;mso-ascii-font-family: 'Times New Roman'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;</span></div></li><li><div style="TEXT-INDENT: 21pt"><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">此时内存中有两个文件名17、</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">35</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">和三个存储其他磁盘页面地址的数据。根据算法我们发现：17&lt;29&lt;35，因此我们找到指针</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">p2</span><span style="font-family:宋体;color:black;mso-ascii-font-family: 'Times New Roman'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Times New Roman'">。</span></div></li><li><div style="TEXT-INDENT: 21pt"><span style="font-family:宋体;">根据<span style="color:black;mso-bidi-font-size: 10.5pt">p2</span><span style="color:black;mso-bidi-font-size: 10.5pt">指针，我们定位到磁盘块3，并将其中的信息导入内存。【磁盘</span><span style="color:black;mso-bidi-font-size: 10.5pt">IO</span><span style="color:black;mso-bidi-font-size: 10.5pt">操作 2次】</span><span style="font-family:'Times New Roman';color:black;mso-ascii-font-family: 'Times New Roman'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div></li><li><div style="TEXT-INDENT: 21pt"><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">此时内存中有两个文件名26，</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">30</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">和三个存储其他磁盘页面地址的数据。根据算法我们发现：26&lt;29&lt;30，因此我们找到指针</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">p2</span><span style="font-family:宋体;color:black;mso-ascii-font-family: 'Times New Roman'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Times New Roman'">。</span></div></li><li><div style="TEXT-INDENT: 21pt"><span style="font-family:宋体;">根据<span style="color:black;mso-bidi-font-size: 10.5pt">p2</span><span style="color:black;mso-bidi-font-size: 10.5pt">指针，我们定位到磁盘块8，并将其中的信息导入内存。【磁盘</span><span style="color:black;mso-bidi-font-size: 10.5pt">IO</span><span style="color:black;mso-bidi-font-size: 10.5pt">操作 3次】</span><span style="font-family:'Times New Roman';color:black;mso-ascii-font-family: 'Times New Roman'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp;</span></span></div></li><li><div style="TEXT-INDENT: 21pt"><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">此时内存中有两个文件名28，</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">29</span><span style="font-family:宋体;color:black;mso-bidi-font-size: 10.5pt">。根据算法我们查找到文件名29，并定位了该文件内存的磁盘地址。</span></div></li></ol><p style="TEXT-INDENT: 21pt"><span style="font-family:宋体;color:black;mso-ascii-font-family: 'Times New Roman'; mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 'Times New Roman'">分析上面的过程，发现需要<strong>3</strong></span><strong><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">次磁盘IO操作和</span></span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">3</span></strong><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;"><strong>次内存查找</strong>操作。关于内存中的文件名查找，由于是一个有序表结构，可以利用折半查找提高效率。至于</span></span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">IO</span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">操作是影响整个</span><span style="font-family:Times New Roman;">B树查找效率的决定因素。</span></span></p><p style="TEXT-INDENT: 21pt"><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">当然，如果我们使用平衡二叉树的磁盘存储结构来进行查找，磁盘</span></span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">4</span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">次，最多5次，而且文件越多，</span></span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">B</span><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'"><span style="font-family:宋体;">树比平衡二叉树所用的磁盘</span></span>IO<span style="font-family:宋体;"><span style="font-family:'Times New Roman';color:black;FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">操作次数将越少，效率也越高</span></span><span style="font-family:宋体;"><span style="font-family:'Times New Roman';FONT-SIZE: 10.5pt; mso-ascii-font-family: 'Times New Roman'; mso-hansi-font-family: 'Times New Roman'; mso-font-kerning: 1.0pt; mso-bidi-font-family: 'Times New Roman'">。</span></span></p><p></p><div style="TEXT-INDENT: 28px; TEXT-ALIGN: left"><span style="color:#333333;"><span style="LINE-HEIGHT: 20px"></span></span><h3 style="PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-TOP: 0px; FONT-FAMILY: verdana, Arial, Helvetica, sans-serif"><a name="t1" target="_blank"></a><span style="color:#ffc00;PADDING-RIGHT: 0px; PADDING-LEFT: 0px; PADDING-BOTTOM: 0px; MARGIN: 0px; PADDING-TOP: 0px"><span style="font-family: 微软雅黑; font-size: 13px;  text-indent: 28px; "><strong>3.4B树的高度</strong></span></span></h3><p style="FONT-SIZE: 14px; PADDING-BOTTOM: 0px; MARGIN: 5px auto; COLOR: rgb(51,51,51); LINE-HEIGHT: 25px; PADDING-TOP: 0px; FONT-FAMILY: verdana, Arial, Helvetica, sans-serif">&nbsp;&nbsp;&nbsp; 根据上面的例子我们可以看出，对于辅存做IO读的次数取决于B树的高度。而B树的高度由什么决定的呢？</p>&nbsp; &nbsp; 若B树某一非叶子节点包含N个关键字，则此非叶子节点含有N+1个孩子结点，而所有的叶子结点都在第I层，我们可以得出：</div><div style="TEXT-INDENT: 28px; TEXT-ALIGN: left"><ol><li>因为根至少有两个孩子，因此第2层至少有两个结点。</li><li>除根和叶子外，其它结点至少有┌m/2┐个孩子，</li><li>因此在第3层至少有2*┌m/2┐个结点，</li><li>在第4层至少有2*(┌m/2┐^2)个结点，</li><li>在第 I 层至少有2*(┌m/2┐^(l-2) )个结点，于是有：&nbsp;N+1 ≥ 2*┌m/2┐I-2；</li><li>考虑第L层的结点个数为N+1，那么2*(┌m/2┐^(l-2)）≤N+1，也就是L层的最少结点数刚好达到N+1个，即： I≤ log┌m/2┐((N+1)/2 )+2；</li></ol></div><div style="TEXT-INDENT: 28px; TEXT-ALIGN: left"><div class="spctrl"></div>　　所以</div><div style="TEXT-INDENT: 28px; TEXT-ALIGN: left"><ul><li>当B树包含N个关键字时，B树的最大高度为l-1（因为计算B树高度时，叶结点所在层不计算在内），即：l - 1 =&nbsp;<strong>log┌m/2┐((N+1)/2 )+1</strong>。</li></ul><div class="spctrl"></div>　　这个B树的高度公式从侧面显示了B树的查找效率是相当高的<span style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;color:#333333;LINE-HEIGHT: 25px">。</span></div><div style="TEXT-INDENT: 28px; TEXT-ALIGN: left"><span style="font-family:verdana, Arial, Helvetica, sans-serif;font-size:14px;color:#333333;LINE-HEIGHT: 25px"><span style="font-size: 13px; color: rgb(51, 51, 51); line-height: 20px;">曾在一次面试中被问到，</span><span style="font-size: 13px; text-indent: 28px; line-height: 20px;"><span style="color: rgb(204, 0, 0);">一棵含有N个总关键字数的m阶的B树的最大高度是多少</span></span><span style="font-size: 13px; text-indent: 28px; color: rgb(51, 51, 51); line-height: 20px;">?答曰：log_<span style="font-size: 12px;">ceil（m/2）</span><span style="font-size: 14px;">(N+1)/2</span>&nbsp;+ 1 （上面中关于m阶B树的第1点特性已经提到：<span style="color: black;"><span style="font-family: Verdana;">树中每个结点含有最多含有m个孩子，即m满足：<span style="font-family: 'Times New Roman';">ceil(m</span><span style="font-family: 'Times New Roman';">/2)</span>&lt;=<strong><span style="color: rgb(51, 51, 51);">m</span></strong>&lt;=m。而</span></span>树中每个结点含孩子数越少，树的高度则越大，故如此）。在2012微软4月份的笔试中也问到了此问题。</span><br></span></div><div style="TEXT-INDENT: 28px; TEXT-ALIGN: left"><span style="color:#333333;LINE-HEIGHT: 25px"><span style="font-size:12px;"><span style="font-family:Arial;">此外，还有读者反馈，说上面的B树的高度计算公式与算法导论一书上的不同，而后我特意翻看了算法导论第18章关于B树的高度一节的内容，如下图所示：</span></span></span></div><div style="TEXT-INDENT: 28px; TEXT-ALIGN: left"><span style="font-size:12px;"><span style="font-family:Arial;"><img style="COLOR: rgb(51,51,51); LINE-HEIGHT: 25px" height="430" alt="" src="http://img.my.csdn.net/uploads/201209/27/1348727095_3238.jpg" width="636"></span></span></div><div style="TEXT-INDENT: 28px; TEXT-ALIGN: left"><span style="font-size:12px;"><span style="font-family:SimSun;">在上图中书上所举的例子中，也许，根据我们大多数人的理解，它的高度应该是4，而书上却说的是“一棵高度为3的B树”。我想，此时，你也就明白了，算法导论一书上的高度的定义是从“0”开始计数的，而我们中国人的习惯是树的高度是从“1”开始计数的。特此说明。July、二零一二年九月二十七日。</span></span></div><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><strong><span style="font-family:宋体;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体; mso-fareast-font-family: 微软雅黑"><span style="FONT-SIZE: 13px">4.</span></span></strong><a target="_blank" name="OLE_LINK3"><strong><span style="font-family:Verdana;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">B<sup>+</sup>-tree</span></span></strong></a></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><a target="_blank" name="OLE_LINK5"><strong><strong><span style="FONT-SIZE: 13px">B<sup>+</sup>-tree</span></strong></strong></a><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">：是应文件系统所需而产生的一种</span></span><a target="_blank" name="OLE_LINK4"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">B-tree</span></span></a><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的变形树。</span><span style="color:black;mso-bidi-font-size: 10.5pt"> </span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">一棵</span><span style="color:black;mso-bidi-font-size: 10.5pt">m</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">阶的</span><span style="color:black;mso-bidi-font-size: 10.5pt">B+</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树和</span><span style="color:black;mso-bidi-font-size: 10.5pt">m</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">阶的</span><span style="color:black;mso-bidi-font-size: 10.5pt">B</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树的异同点在于：</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="font-size: 13px; color: black; "><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>1.</span><span style="font-size: 13px; font-family: 微软雅黑; color: black; ">有</span><span style="font-size: 13px; color: black; ">n</span><span style="font-size: 13px; font-family: 微软雅黑; color: black; ">棵子树的结点中含有</span><span style="font-size: 13px; color: black; ">n-1&nbsp;</span><span style="font-size: 13px; font-family: 微软雅黑; color: black; ">个关键字；</span><span style="font-size: 13px; color: black; ">&nbsp;(此处颇有争议，B+树到底是与B 树</span><span style="font-size: 13px; color: black; ">n</span><span style="font-size: 13px; font-family: 微软雅黑; color: black; ">棵子树有</span><span style="font-size: 13px; color: black; ">n-1</span><span style="color: black; "><span style="font-family: 微软雅黑; font-size: 13px; ">个关键字 保持一致，还是不一致：B树n棵子树的结点中含有n个关键字，待后续查证。暂先提供两个参考链接：①wikipedia&nbsp;</span><span style="font-family:Comic Sans MS;font-size:12px;"><a target="_blank" href="http://en.wikipedia.org/wiki/B%2B_tree#Overview">http://en.wikipedia.org/wiki/B%2B_tree#Overview</a>；②<a target="_blank" href="http://hedengcheng.com/?p=525">http://hedengcheng.com/?p=525</a>。而下面<strong>B+树的图尚未最终确定是否有问题</strong>，请读者注意</span></span><span style="font-size: 13px; color: black; ">)</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>2.</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。</span><span style="color:black;mso-bidi-font-size: 10.5pt"> (而B 树</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的叶子节点并没有包括全部需要查找的信息</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>3.</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt"><span style="color:#333333;"><strong>所有的非终端结点可以看成是索引部分</strong></span>，结点中仅含有其子树根结点中最大（或最小）关键字。</span><span style="color:black;mso-bidi-font-size: 10.5pt"> (而B 树</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的非终节点也包含需要查找的有效信息</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span></span></p><p><span lang="EN-US" style="FONT-SIZE: 10.5pt"><span style="font-family:宋体;"><img height="345" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440587b6WG.jpg" width="569">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 18pt; TEXT-INDENT: -18pt; tab-stops: list 0cm; mso-list: l0 level2 lfo2"><span lang="EN-US" style="mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Verdana; mso-fareast-font-family: Verdana"><span style="mso-list: Ignore"><span style="FONT-SIZE: 13px">a)</span><span style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">为什么说</span></span><a target="_blank" name="OLE_LINK6"><strong><strong><span style="FONT-SIZE: 13px">B<sup>+</sup>-tree</span></strong></strong></a><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">比</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">B 树</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">更适合实际应用中操作系统的文件索引和数据库索引？</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="mso-bidi-font-weight: normal"><span style="color:black;mso-bidi-font-size: 10.5pt">1) <span style="font-family:Verdana;FONT-SIZE: 10.5pt; mso-ansi-language: EN-US; mso-font-kerning: 1.0pt; mso-fareast-font-family: 微软雅黑; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">B<sup>+</sup>-tree</span></span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的磁盘读写代价更低</span><span style="color:black;mso-bidi-font-size: 10.5pt"> </span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; TEXT-INDENT: 21pt"><a target="_blank" name="OLE_LINK7"><strong><strong><span style="FONT-SIZE: 13px">B<sup>+</sup>-tree</span></strong></strong></a><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对</span><span style="color:black;mso-bidi-font-size: 10.5pt">B 树</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说</span><span style="color:black;mso-bidi-font-size: 10.5pt">IO</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">读写次数也就降低了。</span><span style="color:black;mso-bidi-font-size: 10.5pt"> </span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 21pt; tab-stops: list 36.0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </span></span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">举个例子，假设磁盘中的一个盘块容纳</span><span style="color:black;mso-bidi-font-size: 10.5pt">16bytes</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">，而一个关键字</span><span style="color:black;mso-bidi-font-size: 10.5pt">2bytes</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">，一个关键字具体信息指针</span><span style="color:black;mso-bidi-font-size: 10.5pt">2bytes</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">。一棵</span><span style="color:black;mso-bidi-font-size: 10.5pt">9</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">阶</span></span><a target="_blank" name="OLE_LINK8"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">B-tree</span></span></a><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">一个结点最多</span><span style="color:black;mso-bidi-font-size: 10.5pt">8</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">个关键字</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的内部结点需要</span><span style="color:black;mso-bidi-font-size: 10.5pt">2</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">个盘快。而</span><strong><strong>B<sup>+ </sup></strong></strong><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树内部结点只需要</span><span style="color:black;mso-bidi-font-size: 10.5pt">1</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">个盘快。当需要把内部结点读入内存中的时候，</span><span style="color:black;mso-bidi-font-size: 10.5pt">B 树</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">就比</span><strong><strong>B<sup>+ </sup></strong></strong><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树多一次盘块查找时间</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">在磁盘中就是盘片旋转的时间</span><span style="color:black;mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; tab-stops: list 36.0pt"><span style="FONT-SIZE: 13px"><span style="mso-bidi-font-weight: normal"><span style="color:black;mso-bidi-font-size: 10.5pt">2) <span style="font-family:Verdana;FONT-SIZE: 10.5pt; mso-ansi-language: EN-US; mso-font-kerning: 1.0pt; mso-fareast-font-family: 微软雅黑; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">B<sup>+</sup>-tree</span></span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的查询效率更加稳定</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 18pt; TEXT-INDENT: 24pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 18pt; TEXT-INDENT: -18pt; tab-stops: list 0cm; mso-list: l0 level2 lfo2"><span lang="EN-US" style="mso-bidi-font-weight: bold; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Verdana; mso-fareast-font-family: Verdana"><span style="mso-list: Ignore"><span style="FONT-SIZE: 13px"><span style="font-family:Microsoft YaHei;">读者点评</span><br>本文评论下第149楼，fanyy1991针对上文所说的两点，道：个人觉得这两个原因都不是主要原因。数据库索引采用B+树的主要原因是 B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生。B+树只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt 18pt; TEXT-INDENT: -18pt; tab-stops: list 0cm; mso-list: l0 level2 lfo2"><span lang="EN-US" style="mso-bidi-font-weight: bold; mso-bidi-font-size: 10.5pt; mso-bidi-font-family: Verdana; mso-fareast-font-family: Verdana"><span style="mso-list: Ignore"><span style="FONT-SIZE: 13px">b)</span><span style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp; <span style="font-family:Verdana;FONT-SIZE: 10.5pt; mso-ansi-language: EN-US; mso-font-kerning: 1.0pt; mso-fareast-font-family: 微软雅黑; mso-fareast-language: ZH-CN; mso-bidi-language: AR-SA">B<sup>+</sup>-tree</span></span></span></span><span style="FONT-SIZE: 13px">的应用<span lang="EN-US" style="mso-bidi-font-size: 10.5pt">: VSAM(</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">虚拟存储存取法</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">)</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">文件</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">来源论文</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt"> <a target="_blank" name="OLE_LINK10">the ubiquitous Btree</a> </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">作者：</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">D COMER - 1979 )</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt">&nbsp;</p><p class="MsoNormal" style="PADDING-LEFT: 30px; MARGIN: 0cm 0cm 0pt"><strong><span style="font-family:宋体;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体; mso-fareast-font-family: 微软雅黑"><span style="FONT-SIZE: 13px"><img height="255" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307441102xMB4.jpg" width="588">&nbsp;</span></span></strong></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 13px"><strong><span style="font-family:宋体;mso-bidi-font-size: 10.5pt; mso-bidi-font-family: 宋体; mso-fareast-font-family: 微软雅黑">5.</span><span style="font-family:Verdana;mso-bidi-font-size: 10.5pt">B<sup>*</sup>-tree</span></strong></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="font-size: 13px; color: black;">B*-tree</span><span style="font-size: 13px; font-family: 微软雅黑; color: black;">是</span><span style="font-size: 13px; "><strong><strong>B<sup>+</sup>-tree</strong></strong></span><span style="font-size: 13px; font-family: 微软雅黑; color: black;">的变体，在</span><span style="font-size: 13px; "><strong><strong>B<sup>+</sup></strong></strong></span><span style="font-family: 微软雅黑; color: black;"><span style="font-size:12px;">树的基础上(</span><span style="font-family: 微软雅黑; text-indent: 28px;"><span style="font-size:12px;">所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针</span></span><span style="font-size:12px;">)，B*树中非根和非叶子结点再增加指向兄弟的指针；</span></span><span style="font-size: 13px; color: black;">B*</span><span style="font-size: 13px; font-family: 微软雅黑; color: black;">树定义了非叶子结点关键字个数至少为</span><span style="font-size: 13px; color: black;">(2/3)*M</span><span style="font-size: 13px; font-family: 微软雅黑; color: black;">，即块的最低使用率为</span><span style="font-size: 13px; color: black;">2/3</span><span style="font-size: 13px; font-family: 微软雅黑; color: black;">（代替</span><span style="font-size: 13px; color: black;">B+</span><span style="font-size: 13px; font-family: 微软雅黑; color: black;">树的</span><span style="font-size: 13px; color: black;">1/2</span><span style="font-size: 13px; font-family: 微软雅黑; color: black;">）。给出了一个简单实例，如下图所示：</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><img height="345" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_13074405869mSW.jpg" width="569"></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">B+</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树的分裂：当一个结点满时，分配一个新的结点，并将原结点中</span><span style="color:black;mso-bidi-font-size: 10.5pt">1/2</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的数据复制到新结点，最后在父结点中增加新结点的指针；</span><span style="color:black;mso-bidi-font-size: 10.5pt">B+</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">B*</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制</span><span style="color:black;mso-bidi-font-size: 10.5pt">1/3</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的数据到新结点，最后在父结点增加新结点的指针。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">所以，</span><span style="color:black;mso-bidi-font-size: 10.5pt">B*</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树分配新结点的概率比</span><span style="color:black;mso-bidi-font-size: 10.5pt">B+</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树要低，空间使用率更高；</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px"><strong>6、B树的插入、删除操作</strong></span></span></p><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px"></span></span><div class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';mso-spacerun: 'yes'">上面</span><span style="font-family:'宋体';mso-spacerun: 'yes'">第<span style="font-family:Times New Roman;">3</span><span style="font-family:宋体;">小节</span></span><span style="font-family:'宋体';mso-spacerun: 'yes'">简单介绍了利用<span style="font-family:Times New Roman;">B</span><span style="font-family:宋体;">树这种结构如何访问外存磁盘中的数据的情况，下面咱们通过另外一个实例来对这棵</span><span style="font-family:Times New Roman;">B</span><span style="font-family:宋体;">树的插入（</span><span style="font-family:Times New Roman;">insert</span><span style="font-family:宋体;">）</span><span style="font-family:Times New Roman;">,</span><span style="font-family:宋体;">删除（</span><span style="font-family:Times New Roman;">delete</span><span style="font-family:宋体;">）基本操作进行详细的介绍。</span></span></div><div class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt"><span style="LINE-HEIGHT: 150%; FONT-FAMILY: 宋体"><span style="FONT-FAMILY: 宋体">但在此之前，咱们还得简单回顾下<span style="FONT-FAMILY: Verdana"><span style="color:#333333;"><span style="TEXT-DECORATION: underline">一棵<span lang="EN-US" style="mso-bidi-font-size: 10.5pt">m</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">阶的</span><span lang="EN-US" style="mso-bidi-font-size: 10.5pt">B </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树</span>的特性</span>，如下： </span></span></span></span><ol style="LINE-HEIGHT: 150%"><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 12.5pt; COLOR: #000000; FONT-FAMILY: 'Verdana'; mso-spacerun: 'yes'"><span style="FONT-FAMILY: 宋体"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="font-family:Verdana;">树中每个结点含有最多含有m个孩子，即m满足：<span style="font-family:'Times New Roman';color:#000000;mso-spacerun: 'yes'">ceil(m</span><span style="font-family:'Times New Roman';color:#000000;mso-spacerun: 'yes'">/2)</span>&lt;=<strong><span style="color:#333333;">m</span></strong>&lt;=m。</span></span></span></span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">除根结点和叶子结点外，其它每个结点至少有[ceil(m / 2)]个孩子（<span style="font-family:'宋体';color:#000000;FONT-SIZE: 12pt; mso-spacerun: 'yes'">其中ceil(x)是一个取上限的函数</span>）； </span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">若根结点不是叶子结点，则至少有2个孩子（特殊情况：没有孩子的根结点，即根结点为叶子结点，整棵树只有一个根节点）； </span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">所有叶子结点都出现在同一层，叶子结点不包含任何关键字信息(可以看做是外部接点或查询失败的接点，实际上这些结点不存在，指向这些结点的指针都为null)； </span></span></div></li><li><div class="p0" style="PADDING-RIGHT: 0pt; MARGIN-TOP: 0pt; PADDING-LEFT: 0pt; MARGIN-BOTTOM: 0pt; PADDING-BOTTOM: 0pt; PADDING-TOP: 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">每个非终端结点中包含有n个关键字信息： (n，P0，K1，P1，K2，P2，......，Kn，Pn)。其中：<br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;a)&nbsp;&nbsp; Ki (i=1...n)为关键字，且关键字按顺序升序排序K(i-1)&lt; Ki。 <br>&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;b)&nbsp;&nbsp; Pi为指向子树根的接点，且指针P(i-1)指向子树种所有结点的关键字均小于Ki，但都大于K(i-1)。&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c)&nbsp;&nbsp; 除根结点之外的结点的关键字的个数n必须满足： [ceil(m / 2)-1]&lt;= n &lt;= m-1（<span style="color:#333333;">叶子结点也必须满足此条关于关键字数的性质，根结点除外</span>）。</span></span></div></li></ol><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';mso-spacerun: 'yes'"><span style="color:#000000;">ok，下面咱们以一棵<strong>5阶</strong>（即<span style="color:#990000;">树中任一结点至多含有4个关键字，5棵子树</span>）<span style="font-family:Times New Roman;">B</span><span style="font-family:宋体;">树实例进行讲解</span><span style="font-family:Times New Roman;">(</span><span style="font-family:宋体;">如下图所示</span><span style="font-family:Times New Roman;">)</span><span style="font-family:宋体;">：</span></span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="color:#000000;">备注：</span></span><span style="line-height: 150%; color: rgb(51, 51, 51); font-size: 13px;"><span style="TEXT-DECORATION: underline">关键字数（2-4个）针对--非根结点（包括叶子结点在内），孩子数（3-5个）--针对根结点和叶子结点之外的内结点。当然，根结点是必须至少有2个孩子的，不然就成直线型搜索树了</span></span><span style="line-height: 150%; text-indent: 21pt; font-size: 13px;">。下图中，读者可以看到关键字数2-4个，内结点孩子数3-5个：<img src="http://img.my.csdn.net/uploads/201211/12/1352726383_4027.jpg" alt=""></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">关键字为大写字母，顺序为字母升序。</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">结点定义如下：</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; MARGIN-LEFT: 63pt; LINE-HEIGHT: 150%; TEXT-ALIGN: left"><span style="FONT-SIZE: 13px"><span style="font-family:'新宋体';color:#0000ff;mso-spacerun: 'yes'">typedef</span><span style="font-family:'新宋体';mso-spacerun: 'yes'">&nbsp;</span><span style="font-family:'新宋体';color:#0000ff;mso-spacerun: 'yes'">struct</span><span style="font-family:'新宋体';mso-spacerun: 'yes'">{</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; MARGIN-LEFT: 63pt; LINE-HEIGHT: 150%; TEXT-ALIGN: left"><span style="FONT-SIZE: 13px"><span style="font-family:'新宋体';mso-spacerun: 'yes'">&nbsp;&nbsp;&nbsp;</span><span style="font-family:'新宋体';color:#0000ff;mso-spacerun: 'yes'">int</span><span style="font-family:'新宋体';mso-spacerun: 'yes'">&nbsp;Count;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-family:'新宋体';color:#008000;mso-spacerun: 'yes'">//&nbsp;</span><span style="font-family:'新宋体';color:#008000;mso-spacerun: 'yes'">当前节点中关键元素数目</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; MARGIN-LEFT: 63pt; LINE-HEIGHT: 150%; TEXT-ALIGN: left"><span style="FONT-SIZE: 13px"><span style="font-family:'新宋体';mso-spacerun: 'yes'">&nbsp;&nbsp;&nbsp;ItemType&nbsp;Key[</span><span style="font-family:'新宋体';mso-spacerun: 'yes'">4</span><span style="font-family:'新宋体';mso-spacerun: 'yes'">];&nbsp;&nbsp;&nbsp;</span><span style="font-family:'新宋体';color:#008000;mso-spacerun: 'yes'">//&nbsp;</span><span style="font-family:'新宋体';color:#008000;mso-spacerun: 'yes'">存储关键字元素的数组</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; MARGIN-LEFT: 63pt; LINE-HEIGHT: 150%; TEXT-ALIGN: left"><span style="FONT-SIZE: 13px"><span style="font-family:'新宋体';mso-spacerun: 'yes'">&nbsp;&nbsp;&nbsp;</span><span style="font-family:'新宋体';color:#0000ff;mso-spacerun: 'yes'">long</span><span style="font-family:'新宋体';mso-spacerun: 'yes'">&nbsp;Branch[</span><span style="font-family:'新宋体';mso-spacerun: 'yes'">5</span><span style="font-family:'新宋体';mso-spacerun: 'yes'">];&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="font-family:'新宋体';color:#008000;mso-spacerun: 'yes'">//&nbsp;</span><span style="font-family:'新宋体';color:#008000;mso-spacerun: 'yes'">伪指针数组，(记录数目)方便判断合并和分裂的情况</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; MARGIN-LEFT: 63pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'新宋体';mso-spacerun: 'yes'">}&nbsp;NodeType;</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><strong><span style="FONT-SIZE: 13px"><img height="261" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_13075259082xSX.jpg" width="650"></span></strong></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><strong>6.1、插入（<span style="font-family:Times New Roman;">insert</span><span style="font-family:宋体;">）操作</span></strong></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;FONT-SIZE: 12pt; mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px">插入一个元素时，首先在<span style="font-family:Times New Roman;">B</span><span style="font-family:宋体;">树中是否存在，如果不存在，即在叶子结点处结束，然后在叶子结点中插入该新的元素，注意：如果叶子结点空间足够，这里需要向右移动该叶子结点中大于新插入关键字的元素，如果空间满了以致没有足够的空间去添加新的元素，则将该</span></span><a target="_blank" name="OLE_LINK14"><span style="FONT-SIZE: 13px">结点</span></a><span style="FONT-SIZE: 13px">进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中（当然，如果父结点空间满了，也同样需要“分裂”操作），而且当结点中关键元素向右移动了，相关的指针也需要向右移。如果在根结点插入新元素，空间满了，则进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。如下图所示：</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;FONT-SIZE: 12pt; mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img alt="" src="http://hi.csdn.net/attachment/201112/18/0_1324206104Z6fI.gif"><br></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="COLOR: #000000; FONT-FAMILY: '宋体'; mso-spacerun: 'yes'">1、OK，下面咱们通过一个实例来逐步讲解下。插入以下字符字母到一棵空的<span style="font-family:Times New Roman;">B&nbsp;</span><span style="font-family:宋体;">树中（<span style="TEXT-DECORATION: underline">非根结点<strong><span style="font-family:Times New Roman;color:#333333;">关键字数</span></strong><span style="font-family:宋体;color:#000000;">小了（小于2个）就合并，大了（超过4个）就分裂</span></span>）：</span></span><span style="font-family:'Times New Roman';color:#000000;mso-spacerun: 'yes'">C&nbsp;N&nbsp;G&nbsp;A&nbsp;H&nbsp;E&nbsp;K&nbsp;Q&nbsp;M&nbsp;F&nbsp;W&nbsp;L&nbsp;T&nbsp;Z&nbsp;D&nbsp;P&nbsp;R&nbsp;X&nbsp;Y&nbsp;S</span><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">，<span style="font-family:宋体;">首先，结点空间足够，</span><span style="font-family:Times New Roman;">4</span><span style="font-family:宋体;">个字母插入相同的结点中，如下图：</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; PADDING-LEFT: 180px; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="70" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525908RHSE.jpg" width="187"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">2、当咱们试着插入<span style="font-family:Times New Roman;">H</span><span style="font-family:宋体;">时，结点发现空间不够，以致将其分裂成</span><span style="font-family:Times New Roman;">2</span><span style="font-family:宋体;">个结点，移动中间元素</span><span style="font-family:Times New Roman;">G</span><span style="font-family:宋体;">上移到新的根结点中，在实现过程中，咱们把</span><span style="font-family:Times New Roman;">A</span><span style="font-family:宋体;">和</span><span style="font-family:Times New Roman;">C</span><span style="font-family:宋体;">留在当前结点中，而</span><span style="font-family:Times New Roman;">H</span><span style="font-family:宋体;">和</span><span style="font-family:Times New Roman;">N</span><span style="font-family:宋体;">放置新的其右邻居结点中。如下图：</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; PADDING-LEFT: 120px; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="217" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525905BTbZ.jpg" width="325"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">3、当咱们插入<span style="font-family:Times New Roman;">E,K,Q</span><span style="font-family:宋体;">时，不需要任何分裂操作</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; PADDING-LEFT: 90px; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><img style="FLOAT: left" height="217" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525899vG17.jpg" width="433"></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px">&nbsp;</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px">&nbsp;</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px">&nbsp;</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px">&nbsp;</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px">&nbsp;</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px">&nbsp;</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px">&nbsp;</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px">&nbsp;</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px">&nbsp;</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">4、插入<span style="font-family:Times New Roman;">M</span><span style="font-family:宋体;">需要一次分裂，注意</span><span style="font-family:Times New Roman;">M</span><span style="font-family:宋体;">恰好是中间关键字元素，以致向上移到父节点中</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; PADDING-LEFT: 60px; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="217" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525899h5rR.jpg" width="433"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">5、插入<span style="font-family:Times New Roman;">F,W,L,T</span><span style="font-family:宋体;">不需要任何分裂操作</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="217" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525895Gzrw.jpg" width="649"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">6、插入<span style="font-family:Times New Roman;">Z</span><span style="font-family:宋体;">时，最右的叶子结点空间满了，需要进行分裂操作，中间元素</span><span style="font-family:Times New Roman;">T</span><span style="font-family:宋体;">上移到父节点中，注意通过上移中间元素，树最终还是保持平衡，分裂结果的结点存在</span><span style="font-family:Times New Roman;">2</span><span style="font-family:宋体;">个关键字元素。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="217" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_13075258952zo1.jpg" width="649"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">7、插入<span style="font-family:Times New Roman;">D</span><span style="font-family:宋体;">时，导致最左边的叶子结点被分裂，</span><span style="font-family:Times New Roman;">D</span><span style="font-family:宋体;">恰好也是中间元素，上移到父节点中，然后字母</span><span style="font-family:Times New Roman;">P,R,X,Y</span><span style="font-family:宋体;">陆续插入不需要任何分裂操作（别忘了，树中至多5个孩子）。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;FONT-SIZE: 12pt; mso-spacerun: 'yes'"><strong><span style="FONT-SIZE: 13px"><img height="176" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525895q8j1.jpg" width="614"></span></strong></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">8、最后，当插入<span style="font-family:Times New Roman;">S</span><span style="font-family:宋体;">时，含有</span><span style="font-family:Times New Roman;">N,P,Q,R</span><span style="font-family:宋体;">的结点需要分裂，把中间元素</span><span style="font-family:Times New Roman;">Q</span><span style="font-family:宋体;">上移到父节点中，但是情况来了，父节点中空间已经满了，所以也要进行分裂，将父节点中的中间元素</span><span style="font-family:Times New Roman;">M</span><span style="font-family:宋体;">上移到新形成的根结点中，注意以前在父节点中的第三个指针在修改后包括</span><span style="font-family:Times New Roman;">D</span><span style="font-family:宋体;">和</span><span style="font-family:Times New Roman;">G</span><span style="font-family:宋体;">节点中。这样具体插入操作的完成，下面介绍删除操作，删除操作相对于插入操作要考虑的情况多点。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><strong><span style="FONT-SIZE: 13px"><img height="304" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525894XPqO.jpg" width="627"></span></strong></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><strong>6.2、删除<span style="font-family:Times New Roman;">(delete)</span><span style="font-family:宋体;">操作</span></strong></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="color: rgb(0, 0, 0);"><span style="font-family: 'Times New Roman'; font-size: 12px;">首先查找</span><span style="font-family: 'Times New Roman'; font-size: 13px;">B</span><span style="font-family: 宋体; font-size: 13px;">树中需删除的元素</span><span style="font-family: 'Times New Roman'; font-size: 13px;">,</span><span style="font-family: 宋体; font-size: 13px;">如果该元素在</span><span style="font-family: 'Times New Roman'; font-size: 13px;">B</span><span style="font-size: 12px;"><span style="font-family:宋体;">树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”</span><span style="font-family:SimHei;">或</span><span style="font-family:宋体;">“右孩子最左边的节点”)到父节点中，然后</span></span></span><span style="font-size: 13px; font-family: 宋体; color: rgb(0, 0, 0);">是</span><span style="font-size: 13px; font-family: 'Times New Roman'; color: rgb(0, 0, 0);">移动之后</span><span style="font-size: 13px; font-family: 宋体; color: rgb(0, 0, 0);">的</span><span style="font-size: 13px; font-family: 'Times New Roman'; color: rgb(0, 0, 0);">情况；如果没有，直接</span><span style="font-size: 13px; font-family: 宋体; color: rgb(0, 0, 0);">删除后，</span><span style="font-size: 13px; font-family: 'Times New Roman'; color: rgb(0, 0, 0);">移动之后的情况</span><span style="font-size: 13px; font-family: 宋体; color: rgb(0, 0, 0);">。</span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px">删除元素，移动相应元素之后，</span></span><span style="font-family:'Times New Roman';color:#000000;FONT-SIZE: 12pt; mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px">如果某结点中元素数目（即关键字数）小于</span><a target="_blank" name="OLE_LINK15"><span style="FONT-SIZE: 13px">ceil(m/2)-1</span></a><span style="FONT-SIZE: 13px">，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于ceil(m/2)-1）（<span style="color:#333333;"><strong>还记得第一节中关于B树的第5个特性中的c点么?：&nbsp;c)除根结点之外的结点（包括叶子结点）的关键字的个数n必须满足： （ceil(m / 2)-1）&lt;= n &lt;= m-1。m表示最多含有m个孩子，n表示关键字数。在本小节中举的一颗B树的示例中，关键字数n满足：2&lt;=n&lt;=4</strong></span>），如果丰满，则向父节点借一个元素来满足条件；如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于<span style="font-family:Times New Roman;">ceil(m/2)-1</span><span style="font-family:宋体;">，则该结点与其相邻的某一兄弟结点进行</span><span style="font-family:Times New Roman;">“</span><span style="font-family:宋体;">合并</span>”成一个结点，以此来满足条件。那咱们通过下面实例来详细了解吧。</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="COLOR: #000000; FONT-FAMILY: 'Times New Roman'; mso-spacerun: 'yes'">以上述插入操作构造的一棵5阶<span style="font-family:Times New Roman;">B</span><span style="FONT-FAMILY: 宋体">树（树中最多含有m（m=5）个孩子，因此关键字数最小为<span style="font-family:Times New Roman;color:#333333;"><strong>ceil(m / 2)-1=2。</strong>还是这句话，<span style="TEXT-DECORATION: underline"><strong>关键字数</strong><span style="font-family:宋体;color:#000000;">小了（小于2个）就合并，大了（超过4个）就分裂</span></span></span>）为例，依次删除</span><span style="font-family:Times New Roman;">H,T,R,E</span><span style="font-family:宋体;">。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'Times New Roman';color:#000000;mso-spacerun: 'yes'"><span style="font-family:宋体;"><img height="304" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525894XPqO.jpg" width="627"></span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">1、首先删除元素<span style="font-family:Times New Roman;">H</span><span style="font-family:宋体;">，当然首先查找</span><span style="font-family:Times New Roman;">H</span><span style="font-family:宋体;">，</span><span style="font-family:Times New Roman;">H</span><span style="font-family:宋体;">在一个叶子结点中，且该叶子结点元素数目</span><span style="font-family:Times New Roman;">3</span><span style="font-family:宋体;">大于最小元素数目</span><span style="font-family:Times New Roman;">ceil(m/2)-1=2</span><span style="font-family:宋体;">，则操作很简单，咱们只需要移动</span><span style="font-family:Times New Roman;">K</span><span style="font-family:宋体;">至原来</span><span style="font-family:Times New Roman;">H</span><span style="font-family:宋体;">的位置，移动</span><span style="font-family:Times New Roman;">L</span><span style="font-family:宋体;">至</span><span style="font-family:Times New Roman;">K</span><span style="font-family:宋体;">的位置（也就是结点中删除元素后面的元素向前移动）</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="304" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525891j1B1.jpg" width="627"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">2、下一步，删除<span style="font-family:Times New Roman;">T,</span><span style="font-family:宋体;">因为</span><span style="font-family:Times New Roman;">T</span><span style="font-family:宋体;">没有在叶子结点中，而是在中间结点中找到，咱们发现他的继承者</span><span style="font-family:Times New Roman;">W(</span><span style="font-family:宋体;">字母升序的下个元素</span><span style="font-family:Times New Roman;">)</span><span style="font-family:宋体;">，将</span><span style="font-family:Times New Roman;">W</span><span style="font-family:宋体;">上移到</span><span style="font-family:Times New Roman;">T</span><span style="font-family:宋体;">的位置，然后将原包含</span><span style="font-family:Times New Roman;">W</span><span style="font-family:宋体;">的孩子结点中的</span><span style="font-family:Times New Roman;">W</span><span style="font-family:宋体;">进行删除，这里恰好删除</span><span style="font-family:Times New Roman;">W</span><span style="font-family:宋体;">后，该孩子结点中元素个数大于</span><span style="font-family:Times New Roman;">2</span><span style="font-family:宋体;">，无需进行合并操作。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><img height="287" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525890gB3b.jpg" width="591"></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><a target="_blank" name="OLE_LINK27"></a><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">3、下一步删除<span style="font-family:Times New Roman;">R</span><span style="font-family:宋体;">，</span><span style="font-family:Times New Roman;">R</span><span style="font-family:宋体;">在叶子结点中</span><span style="font-family:Times New Roman;">,</span><span style="font-family:宋体;">但是该结点中元素数目为</span><span style="font-family:Times New Roman;">2</span><span style="font-family:宋体;">，删除导致只有</span><span style="font-family:Times New Roman;">1</span><span style="font-family:宋体;">个元素，已经小于最小元素数目</span><span style="font-family:Times New Roman;">ceil(5/2)-1=2,而由前面我们已经知道：</span><span style="TEXT-DECORATION: underline"><span style="font-family:宋体;">如果其某个相邻兄弟结点中比较丰满（元素个数大于</span><span style="font-family:Times New Roman;">ceil(5/2)-1=2</span></span><span style="font-family:宋体;"><span style="TEXT-DECORATION: underline">），则可以向父结点借一个元素，然后将最丰满的相邻兄弟结点中上移最后或最前一个元素到父节点中</span>（有没有看到红黑树中左旋操作的影子?），在这个实例中，右相邻兄弟结点中比较丰满（</span><span style="font-family:Times New Roman;">3</span><span style="font-family:宋体;">个元素大于</span><span style="font-family:Times New Roman;">2</span><span style="font-family:宋体;">），所以先向父节点借一个元素</span><span style="font-family:Times New Roman;">W</span><span style="font-family:宋体;">下移到该叶子结点中，代替原来</span><span style="font-family:Times New Roman;">S</span><span style="font-family:宋体;">的位置，</span><span style="font-family:Times New Roman;">S</span><span style="font-family:宋体;">前移；然后</span><span style="font-family:Times New Roman;">X</span><span style="font-family:宋体;">在相邻右兄弟结点中上移到父结点中，最后在相邻右兄弟结点中删除</span><span style="font-family:Times New Roman;">X</span><span style="font-family:宋体;">，后面元素前移。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="299" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525887QhC3.jpg" width="615"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">4、最后一步删除<span style="font-family:Times New Roman;">E</span><span style="font-family:宋体;">，&nbsp;删除后会导致很多问题，因为</span><span style="font-family:Times New Roman;">E</span><span style="font-family:宋体;">所在的结点数目刚好达标，刚好满足最小元素个数（</span><span style="font-family:Times New Roman;">ceil(5/2)-1=2</span></span><span style="font-family:'Times New Roman';color:#000000;mso-spacerun: 'yes'">）</span><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">,<span style="font-family:宋体;">而相邻的兄弟结点也是同样的情况，删除一个元素都不能满足条件，所以需要<span style="TEXT-DECORATION: underline">该节点与某相邻兄弟结点进行合并操作</span>；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素</span><span style="font-family:Times New Roman;">D</span><span style="font-family:宋体;">下移到已经删除</span><span style="font-family:Times New Roman;">E</span><span style="font-family:宋体;">而只有</span><span style="font-family:Times New Roman;">F</span><span style="font-family:宋体;">的结点中，然后将含有</span><span style="font-family:Times New Roman;">D</span><span style="font-family:宋体;">和</span><span style="font-family:Times New Roman;">F</span><span style="font-family:宋体;">的结点和含有</span><span style="font-family:Times New Roman;">A,C</span><span style="font-family:宋体;">的相邻兄弟结点进行合并成一个结点。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="276" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525886x2r2.jpg" width="566"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">5、也许你认为这样删除操作已经结束了，其实不然，在看看上图，对于这种特殊情况，你立即会发现父节点只包含一个元素<span style="font-family:Times New Roman;">G</span><span style="font-family:宋体;">，没达标（<span style="color:#333333;">因为非根节点包括叶子结点的关键字数n必须满足于2=&lt;n&lt;=4，而此处的n=1</span>），这是不能够接受的。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有</span><span style="font-family:Times New Roman;">Q,X</span><span style="font-family:宋体;">）有一个以上的元素（</span><span style="font-family:Times New Roman;">Q</span><span style="font-family:宋体;">右边还有元素），然后咱们将</span><span style="font-family:Times New Roman;">M</span><span style="font-family:宋体;">下移到元素很少的子结点中，将</span><span style="font-family:Times New Roman;">Q</span><span style="font-family:宋体;">上移到</span><span style="font-family:Times New Roman;">M</span><span style="font-family:宋体;">的位置，这时，</span><span style="font-family:Times New Roman;">Q</span><span style="font-family:宋体;">的左子树将变成</span><span style="font-family:Times New Roman;">M</span><span style="font-family:宋体;">的右子树，也就是含有</span><span style="font-family:Times New Roman;">N</span><span style="font-family:宋体;">，</span><span style="font-family:Times New Roman;">P</span><span style="font-family:宋体;">结点被依附在</span><span style="font-family:Times New Roman;">M</span><span style="font-family:宋体;">的右指针上。所以在这个实例中，咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素</span><span style="font-family:Times New Roman;">M</span><span style="font-family:宋体;">下移到子结点，这样，树的高度减少一层。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="185" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525883hHW0.jpg" width="554"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">为了进一步详细讨论删除的情况，<span style="color:#333333;"><strong>再举另外一个实例</strong></span>：</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">这里是一棵不同的<span style="font-family:Times New Roman;">5</span><span style="font-family:宋体;">序</span><span style="font-family:Times New Roman;">B</span><span style="font-family:宋体;">树，那咱们试着删除</span><span style="font-family:Times New Roman;">C</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="240" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525877xDde.jpg" width="554"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px">于是将删除元素<span style="font-family:Times New Roman;">C</span><span style="font-family:宋体;">的右子结点中的</span><span style="font-family:Times New Roman;">D</span><span style="font-family:宋体;">元素上移到</span><span style="font-family:Times New Roman;">C</span><span style="font-family:宋体;">的位置，但是出现上移元素后，只有一个元素的结点的情况。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">又因为含有<span style="font-family:Times New Roman;">E</span><span style="font-family:宋体;">的结点，其相邻兄弟结点才刚脱贫（最少元素个数为</span><span style="font-family:Times New Roman;">2</span><span style="font-family:宋体;">），不可能向父节点借元素，所以只能进行合并操作，于是这里将含有</span><span style="font-family:Times New Roman;">A,B</span><span style="font-family:宋体;">的左兄弟结点和含有</span><span style="font-family:Times New Roman;">E</span><span style="font-family:宋体;">的结点进行合并成一个结点。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="256" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_13075258778uzj.jpg" width="590"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">这样又出现只含有一个元素<span style="font-family:Times New Roman;">F</span><span style="font-family:宋体;">结点的情况，这时，其相邻的兄弟结点是丰满的（元素个数为</span><span style="font-family:Times New Roman;">3&gt;</span><span style="font-family:宋体;">最小元素个数</span><span style="font-family:Times New Roman;">2</span></span><span style="font-family:'Times New Roman';color:#000000;mso-spacerun: 'yes'">）</span><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">，这样就可以想父结点借元素了，把父结点中的<span style="font-family:Times New Roman;">J</span><span style="font-family:宋体;">下移到该结点中，相应的如果结点中</span><span style="font-family:Times New Roman;">J</span><span style="font-family:宋体;">后有元素则前移，然后相邻兄弟结点中的第一个元素（或者最后一个元素）上移到父节点中，后面的元素（或者前面的元素）前移（或者后移）；注意含有</span><span style="font-family:Times New Roman;">K</span><span style="font-family:宋体;">，</span><span style="font-family:Times New Roman;">L</span><span style="font-family:宋体;">的结点以前依附在</span><span style="font-family:Times New Roman;">M</span><span style="font-family:宋体;">的左边，现在变为依附在</span><span style="font-family:Times New Roman;">J</span><span style="font-family:宋体;">的右边。这样每个结点都满足</span><span style="font-family:Times New Roman;">B</span><span style="font-family:宋体;">树结构性质。</span></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; TEXT-INDENT: 21pt; LINE-HEIGHT: 150%; TEXT-ALIGN: center">&nbsp;</p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px"><img height="250" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307525873GgD4.jpg" width="578"></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px">从以上操作可看出：<span style="font-family:Times New Roman;color:#333333;">除根结点之外的结点（包括叶子结点）的关键字的个数n满足：（ceil(m / 2)-1）&lt;= n &lt;= m-1，即2&lt;=n&lt;=4。这也佐证了咱们之前的观点。</span>删除操作完。</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; MARGIN-BOTTOM: 0pt; LINE-HEIGHT: 150%">&nbsp;</p><span style="LINE-HEIGHT: 150%; FONT-FAMILY: 宋体"><span style="font-family:宋体;"><span style="font-family:Verdana;"><span style="color:black;mso-bidi-font-size: 10.5pt"><!--EndFragment--></span></span></span></span></div><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 13px"><span style="mso-bidi-font-weight: normal"><strong><span style="color:black;mso-bidi-font-size: 10.5pt">7.</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">总结</span></strong></span></span></p><p class="p0" style="MARGIN-TOP: 0pt; PADDING-LEFT: 30px; MARGIN-BOTTOM: 0pt; LINE-HEIGHT: 150%"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">通过以上介绍，大致将B树，B+树，B*树总结如下：</span></p><p class="p0" style="MARGIN-TOP: 0pt; PADDING-LEFT: 30px; MARGIN-BOTTOM: 0pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">B树：有序数组+平衡多叉树；</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; PADDING-LEFT: 30px; MARGIN-BOTTOM: 0pt; LINE-HEIGHT: 150%"><span style="FONT-SIZE: 13px"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'">B+树：有序数组链表+平衡多叉树；</span></span></p><p class="p0" style="MARGIN-TOP: 0pt; PADDING-LEFT: 30px; MARGIN-BOTTOM: 0pt"><span style="font-family:'宋体';color:#000000;mso-spacerun: 'yes'"><span style="FONT-SIZE: 13px">B*树：一棵丰满的B+树。</span></span><!--EndFragment--></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp; </span></span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">在大规模数据存储的文件系统中，</span><span style="color:black;mso-bidi-font-size: 10.5pt">B~tree</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">系列数据结构，起着很重要的作用，对于存储不同的数据，节点相关的信息也是有所不同，这里根据自己的理解，画的一个查找以职工号为关键字，职工号为</span><span style="color:black;mso-bidi-font-size: 10.5pt">38</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">的记录的简单示意图。</span><span style="color:black;mso-bidi-font-size: 10.5pt">(</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">这里假设每个物理块容纳</span><span style="color:black;mso-bidi-font-size: 10.5pt">3</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">个索引，磁盘的</span><span style="color:black;mso-bidi-font-size: 10.5pt">I/O</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">操作的基本单位是块（</span><span style="color:black;mso-bidi-font-size: 10.5pt">block),</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">磁盘访问很费时，采用</span><span style="color:black;mso-bidi-font-size: 10.5pt">B+</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">树有效的减少了访问磁盘的次数。）</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">对于像</span><span style="color:black;mso-bidi-font-size: 10.5pt">MySQL</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">，</span><span style="color:black;mso-bidi-font-size: 10.5pt">DB2</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">，</span><span style="color:black;mso-bidi-font-size: 10.5pt">Oracle</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">等数据库中的索引结构得有较深入的了解才行，建议去找一些B 树</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">相关的开源代码研究。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt"><img height="318" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440586P5aD.jpg" width="758"></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体"><span style="TEXT-DECORATION: underline">走进搜索引擎的作者梁斌老师</span>针对<span lang="EN-US">B</span>树、<span lang="EN-US">B+</span>树给出了他的意见（为了真实性，特引用其原话，未作任何改动）：</span><span style="font-family:宋体;mso-ascii-font-family: 微软雅黑; mso-bidi-font-size: 10.5pt; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体; mso-fareast-font-family: 微软雅黑">&nbsp;“</span><span style="font-family:微软雅黑;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体">B+</span><span style="font-family:微软雅黑;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体">树还有一个最大的好处，方便扫库，<span lang="EN-US">B</span>树必须用中序遍历的方法按序扫库，而<span lang="EN-US">B+</span>树直接从叶子结点挨个扫一遍就完了，<span lang="EN-US">B+</span>树支持<span lang="EN-US">range-query</span>非常方便，而<span lang="EN-US">B</span>树不支持。这是数据库选用<span lang="EN-US">B+</span>树的最主要原因。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan" align="left"><span style="font-family:微软雅黑;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体"><span style="FONT-SIZE: 13px">&nbsp;&nbsp;&nbsp; 比如要查<span lang="EN-US"> 5-10</span>之间的，<span lang="EN-US">B+</span>树一把到<span lang="EN-US">5</span>这个标记，再一把到<span lang="EN-US">10</span>，然后串起来就行了，<span lang="EN-US">B</span>树就非常麻烦。<span lang="EN-US">B</span>树的好处，就是成功查询特别有利，因为树的高度总体要比<span lang="EN-US">B+</span>树矮。不成功的情况下，<span lang="EN-US">B</span>树也比<span lang="EN-US">B+</span>树稍稍占一点点便宜。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan" align="left"><span style="font-family:微软雅黑;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体"><span style="FONT-SIZE: 13px">&nbsp;&nbsp;&nbsp; B</span></span><span style="font-family:微软雅黑;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体"><span style="FONT-SIZE: 13px">树比如你的例子中查，<span lang="EN-US">17</span>的话，一把就得到结果了，</span><span lang="EN-US"><br></span><span style="FONT-SIZE: 13px">有很多基于频率的搜索是选用<span lang="EN-US">B</span>树，越频繁<span lang="EN-US">query</span>的结点越往根上走，前提是需要对<span lang="EN-US">query</span>做统计，而且要对<span lang="EN-US">key</span>做一些变化。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan" align="left"><span style="font-family:微软雅黑;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体"><span style="FONT-SIZE: 13px">&nbsp;&nbsp;&nbsp; 另外<span lang="EN-US">B</span>树也好<span lang="EN-US">B+</span>树也好，根或者上面几层因为被反复<span lang="EN-US">query</span>，所以这几块基本都在内存中，不会出现读磁盘<span lang="EN-US">IO</span>，一般已启动的时候，就会主动换入内存。”非常感谢。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan" align="left"><span style="font-family:微软雅黑;mso-bidi-font-size: 10.5pt; mso-hansi-font-family: 宋体; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体"><span style="FONT-SIZE: 13px">&nbsp;&nbsp;&nbsp; <span style="TEXT-DECORATION: underline">Bucket Li</span>："mysql 底层存储是用B+树实现的，知道为什么么。内存中B+树是没有优势的，但是一到磁盘，B+树的威力就出来了"。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><br></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt"><span style="mso-bidi-font-weight: normal"></span></p><h2><a name="t2" target="_blank"></a><span style="mso-bidi-font-weight: normal"><strong><span style="font-family:微软雅黑;FONT-SIZE: 14pt; mso-ascii-font-family: Verdana">第二节、</span><span lang="EN-US" style="FONT-SIZE: 14pt">R</span><span style="font-family:微软雅黑;FONT-SIZE: 14pt; mso-ascii-font-family: Verdana">树：处理空间存储问题</span></strong></span></h2><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">相信经过上面第一节的介绍，你已经对</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树或者</span><span lang="EN-US">B+</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树有所了解。这种树可以非常好的处理一维空间存储的问题。</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树是一棵平衡树，它是把一维直线分为若干段线段，当我们查找满足某个要求的点的时候，只要去查找它所属的线段即可。依我看来，这种思想其实就是先找一个大的空间，再逐步缩小所要查找的空间，最终在一个自己设定的最小不可分空间内找出满足要求的解。一个典型的</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树查找如下：</span></span></p><p class="MsoNormal" style="PADDING-LEFT: 30px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left"><img height="88" alt="" src="http://hi.csdn.net/attachment/8394323_1309333599R7EU.jpg" width="318">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="FONT-SIZE: 13px">要查找某一满足条件的点，先去找到满足条件的线段，然后遍历所在线段上的点，即可找到答案。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树是一种相对来说比较复杂的数据结构，尤其是在它的删除与插入操作过程中，因为它涉及到了叶子结点的分解与合并。由于本文第一节已经详细介绍了</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树和</span><span lang="EN-US">B+</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树，下面直接开始介绍我们的第二个主角：</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><h3><a name="t3" target="_blank"></a><span style="mso-bidi-font-weight: normal"><span style="font-family:微软雅黑;FONT-SIZE: 12pt; mso-ascii-font-family: Verdana; mso-bidi-font-size: 11.0pt">简介</span></span></h3><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">1984</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">年，加州大学伯克利分校的</span><span lang="EN-US">Guttman</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">发表了一篇题为</span><span style="mso-bidi-font-style: normal"><span style="font-family:Arial;FONT-SIZE: 12pt; mso-font-kerning: 0pt; mso-fareast-font-family: 宋体">“R-trees: a dynamic index structure for spatial searching”</span></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的论文，向世人介绍了</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树这种处理高维空间存储问题的数据结构。本文便是基于这篇论文写作完成的，因此如果大家对</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树非常有兴趣，我想最好还是参考一下原著：）。为表示对这位牛人的尊重，给个引用先：</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left; mso-pagination: widow-orphan" align="left"><span style="font-family:Arial;FONT-SIZE: 12pt; mso-font-kerning: 0pt; mso-fareast-font-family: 宋体">Guttman, A.; <span style="mso-bidi-font-style: normal">“R-trees: a dynamic index structure for spatial searching,”</span> <span style="mso-bidi-font-style: italic">ACM, </span><span style="mso-bidi-font-weight: bold">1984</span><span style="mso-bidi-font-style: italic">, 14</span></span><span style="font-family:宋体;FONT-SIZE: 12pt; mso-font-kerning: 0pt; mso-bidi-font-family: 宋体"> </span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">R树</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">在数据库等领域做出的功绩是非常显著的。它很好的解决了在高维空间搜索等问题。举个</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树在现实领域中能够解决的例子：查找</span><span lang="EN-US">20</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">英里以内所有的餐厅。如果没有</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树你会怎么解决？一般情况下我们会把餐厅的坐标</span><span lang="EN-US">(x,y)</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">分为两个字段存放在数据库中，一个字段记录经度，另一个字段记录纬度。这样的话我们就需要遍历所有的餐厅获取其位置信息，然后计算是否满足要求。如果一个地区有</span><span lang="EN-US">100</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">家餐厅的话，我们就要进行</span><span lang="EN-US">100</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">次位置计算操作了，如果应用到谷歌地图这种超大数据库中，这种方法便必定不可行了。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树就很好的解决了这种高维空间搜索问题。它把</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的思想很好的扩展到了多维空间，采用了</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树分割空间的思想，并在添加、删除操作时采用合并、分解结点的方法，保证树的平衡性。因此，</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树就是一棵用来存储高维数据的平衡树。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">OK，接下来，本文将详细介绍</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的数据结构以及</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的操作。至于</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的扩展与</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的性能问题，可以查阅相关论文。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><h3><a name="t4" target="_blank"></a><span style="mso-bidi-font-weight: normal"><span lang="EN-US" style="FONT-SIZE: 12pt; mso-bidi-font-size: 11.0pt">R</span><span style="font-family:微软雅黑;FONT-SIZE: 12pt; mso-ascii-font-family: Verdana; mso-bidi-font-size: 11.0pt">树的数据结构</span></span></h3><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如上所述，</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树是</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树在高维空间的扩展，是一棵平衡树。每个</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的叶子结点包含了多个指向不同数据的指针，这些数据可以是存放在硬盘中的，也可以是存在内存中。根据</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的这种数据结构，当我们需要进行一个高维空间查询时，我们只需要遍历少数几个叶子结点所包含的指针，查看这些指针指向的数据是否满足要求即可。这种方式使我们不必遍历所有数据即可获得答案，效率显著提高。下图1是R树的一个简单实例：</span></span></p><p class="MsoNormal" style="PADDING-LEFT: 30px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><img height="317" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_130749300836fQ.jpg" width="342"></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">我们在上面说过，</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树运用了空间分割的理念，这种理念是如何实现的呢？</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树采用了一种称为</span><span lang="EN-US">MBR(Minimal Bounding Rectangle)</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的方法，在此我把它译作“最小边界矩形”。从叶子结点开始用矩形（</span><span lang="EN-US">rectangle</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">）将空间框起来，结点越往上，框住的空间就越大，以此对空间进行分割。有点不懂？没关系，继续往下看。在这里我还想提一下，</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树中的</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">应该代表的是</span><span lang="EN-US">Rectangle</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">（此处参考</span><span lang="EN-US">wikipedia上关于<a target="_blank" href="http://en.wikipedia.org/wiki/R-tree">R树</a>的介绍</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">），而不是大多数国内教材中所说的</span><span lang="EN-US">Region</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">（很多书把</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树称为区域树，这是有误的）。我们就拿二维空间来举例。下图是</span><span lang="EN-US">Guttman</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">论文中的一幅图：</span></span></p><p class="MsoNormal" style="PADDING-LEFT: 30px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px"><img height="443" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440584OHk3.jpg" width="347">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">我来详细解释一下这张图。先来看图（</span><span lang="EN-US">b</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">）</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"></p><ol><li><span style="font-size: 13px; font-family: 微软雅黑;">首先我们假设所有数据都是二维空间下的点，图中仅仅标志了</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R8</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">区域中的数据，也就是那个</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">shape of data object</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">。别把那一块不规则图形看成一个数据，我们把它看作是多个数据围成的一个区域。为了实现</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">树结构，我们用一个最小边界矩形恰好框住这个不规则区域，这样，我们就构造出了一个区域：</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R8</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">。</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R8</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">的特点很明显，就是正正好好框住所有在此区域中的数据。其他实线包围住的区域，如</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R9</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">，</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R10</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">，</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R12</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">等都是同样的道理。这样一来，我们一共得到了</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">12</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">个最最基本的最小矩形。这些矩形都将被存储在子结点中。</span></li><li><span style="font-size: 13px; font-family: 微软雅黑;">下一步操作就是进行高一层次的处理。我们发现</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R8</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">，</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R9</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">，</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R10</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">三个矩形距离最为靠近，因此就可以用一个更大的矩形</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R3</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">恰好框住这</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">3</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">个矩形。</span></li><li><span style="font-size: 13px; font-family: 微软雅黑;">同样道理，</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R15</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">，</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R16</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">被</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R6</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">恰好框住，</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R11</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">，</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R12</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">被</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R4</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">恰好框住，等等。所有最基本的最小边界矩形被框入更大的矩形中之后，再次迭代，用更大的框去框住这些矩形。</span></li></ol><p></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">我想大家都应该理解这个数据结构的特征了。<span style="TEXT-DECORATION: underline">用地图的例子来解释，就是所有的数据都是餐厅所对应的地点，先把相邻的餐厅划分到同一块区域，划分好所有餐厅之后，再把邻近的区域划分到更大的区域，划分完毕后再次进行更高层次的划分，直到划分到只剩下两个最大的区域为止。要查找的时候就方便了</span>。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">下面就可以把这些大大小小的矩形存入我们的</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树中去了。根结点存放的是两个最大的矩形，这两个最大的矩形框住了所有的剩余的矩形，当然也就框住了所有的数据。下一层的结点存放了次大的矩形，这些矩形缩小了范围。每个叶子结点都是存放的最小的矩形，这些矩形中可能包含有</span><span lang="EN-US">n</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">个数据。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="FONT-SIZE: 13px">在这里，读者先不要去纠结于如何划分数据到最小区域矩形，也不要纠结怎样用更大的矩形框住小矩形，这些都是下一节我们要讨论的。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">讲完了基本的数据结构，我们来讲个实例，如何查询特定的数据。又以餐厅为例，假设我要查询广州市天河区天河城附近一公里的所有餐厅地址怎么办？</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"></p><ol><li><span style="font-size: 13px; font-family: 微软雅黑;">打开地图（也就是整个</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">树），先选择国内还是国外（也就是根结点）。</span></li><li><span style="font-family: 微软雅黑; font-size: 13px; text-indent: 21pt;">然后选择华南地区（对应第一层结点），选择广州市（对应第二层结点），</span></li><li><span style="font-family: 微软雅黑; font-size: 13px; text-indent: 21pt;">再选择天河区（对应第三层结点），</span></li><li><span style="font-family: 微软雅黑; font-size: 13px; text-indent: 21pt;">最后选择天河城所在的那个区域（对应叶子结点，存放有最小矩形），遍历所有在此区域内的结点，看是否满足我们的要求即可。</span></li></ol><p></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="font-size: 13px; font-family: 微软雅黑;">怎么样，其实</span><span lang="EN-US" style="font-size: 13px; text-indent: 21pt;">R</span><span style="font-size: 13px; text-indent: 21pt; font-family: 微软雅黑;">树的查找规则跟查地图很像吧？对应下图：</span></p><p class="MsoNormal" style="PADDING-LEFT: 30px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><img height="341" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307492843D0oO.jpg" width="445"></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><strong></strong></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><strong><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">一棵</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树满足如下的性质：</span></strong></span></p><p class="ListParagraph" style="MARGIN: 0cm 0cm 0pt 18pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-list: l1 level1 lfo1; mso-char-indent-count: 0" align="left"><span lang="EN-US" style="mso-bidi-font-family: Verdana; mso-fareast-font-family: Verdana"><span style="mso-list: Ignore"><span style="FONT-SIZE: 13px">1.</span><span style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">除非它是根结点之外，所有叶子结点包含有</span><span lang="EN-US">m</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">至</span><span lang="EN-US">M</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">个记录索引（条目）。作为根结点的叶子结点所具有的记录个数可以少于</span><span lang="EN-US">m</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。通常，</span><span lang="EN-US">m=M/2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></span></p><p class="ListParagraph" style="MARGIN: 0cm 0cm 0pt 18pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-list: l1 level1 lfo1; mso-char-indent-count: 0" align="left"><span lang="EN-US" style="mso-bidi-font-family: Verdana; mso-fareast-font-family: Verdana"><span style="mso-list: Ignore"><span style="FONT-SIZE: 13px">2.</span><span style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">对于所有在叶子中存储的记录（条目），</span><span lang="EN-US">I</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">是最小的可以在空间中完全覆盖这些记录所代表的点的矩形（注意：此处所说的“矩形”是可以扩展到高维空间的）。</span></span></p><p class="ListParagraph" style="MARGIN: 0cm 0cm 0pt 18pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-list: l1 level1 lfo1; mso-char-indent-count: 0" align="left"><span lang="EN-US" style="mso-bidi-font-family: Verdana; mso-fareast-font-family: Verdana"><span style="mso-list: Ignore"><span style="FONT-SIZE: 13px">3.</span><span style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">每一个非叶子结点拥有</span><span lang="EN-US">m</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">至</span><span lang="EN-US">M</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">个孩子结点，除非它是根结点。</span></span></p><p class="ListParagraph" style="MARGIN: 0cm 0cm 0pt 18pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-list: l1 level1 lfo1; mso-char-indent-count: 0" align="left"><span lang="EN-US" style="mso-bidi-font-family: Verdana; mso-fareast-font-family: Verdana"><span style="mso-list: Ignore"><span style="FONT-SIZE: 13px">4.</span><span style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">对于在非叶子结点上的每一个条目，</span><span lang="EN-US">i</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">是最小的可以在空间上完全覆盖这些条目所代表的店的矩形（同性质</span><span lang="EN-US">2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">）。</span></span></p><p class="ListParagraph" style="MARGIN: 0cm 0cm 0pt 18pt; TEXT-INDENT: -18pt; TEXT-ALIGN: left; mso-list: l1 level1 lfo1; mso-char-indent-count: 0" align="left"><span lang="EN-US" style="mso-bidi-font-family: Verdana; mso-fareast-font-family: Verdana"><span style="mso-list: Ignore"><span style="FONT-SIZE: 13px">5.</span><span style="FONT: 7pt 'Times New Roman'">&nbsp;&nbsp;&nbsp;&nbsp; </span></span></span><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所有叶子结点都位于同一层，因此</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树为平衡树。</span></span></p><h4><a name="t5" target="_blank"></a><span style="mso-bidi-font-weight: normal"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">叶子结点的结构</span></span></span></h4><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">先来探究一下叶子结点的结构。叶子结点所保存的数据形式为：</span><span lang="EN-US">(I, tuple-identifier)</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">其中，</span><span lang="EN-US">tuple-identifier</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">表示的是一个存放于数据库中的</span><span lang="EN-US">tuple</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，也就是一条记录，它是</span><span lang="EN-US">n</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">维的。</span><span lang="EN-US">I</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">是一个</span><span lang="EN-US">n</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">维空间的矩形，并可以恰好框住这个叶子结点中所有记录代表的</span><span lang="EN-US">n</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">维空间中的点。</span><span lang="EN-US">I=(I<sub>0</sub>,I<sub>1</sub>,…,I<sub>n-1</sub>)</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。其结构如下图所示：</span></span></p><p class="MsoNormal" style="PADDING-LEFT: 30px; MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><img height="133" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307512429kp03.jpg" width="408"></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="FONT-SIZE: 13px">下图描述的就是在二维空间中的叶子结点所要存储的信息。</span></span></p><p class="MsoNormal" style="PADDING-LEFT: 60px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left"><img height="176" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440584MfmI.jpg" width="309">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">在这张图中，</span><span lang="EN-US">I</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所代表的就是图中的矩形，其范围是</span><span lang="EN-US">a&lt;=I<sub>0</sub>&lt;=b</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，</span><span lang="EN-US">c&lt;=I<sub>1</sub>&lt;=d</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。有两个</span><span lang="EN-US">tuple-identifier</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，在图中即表示为那两个点。这种形式完全可以推广到高维空间。大家简单想想三维空间中的样子就可以了。这样，叶子结点的结构就介绍完了。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><h4><a name="t6" target="_blank"></a><span style="mso-bidi-font-weight: normal"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">非叶子结点</span></span></span></h4><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">非叶子结点的结构其实与叶子结点非常类似。<span style="color:#000000;">想象一下</span></span><span style="color:#333333;"><span style="color:#000000;"><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树就知道了，</span></span><span lang="EN-US">B</span></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="color:#333333;">树的叶子结点存放的是真实存在的数据，而非叶子结点存放的是这些数据的“边界”，或者说也算是一种索引（<span style="color:#000000;">有疑问的读者可以回顾一下上述第一节中讲解B树的部分</span>）</span>。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">同样道理，</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的非叶子结点存放的数据结构为：</span><span lang="EN-US">(I, child-pointer)</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">其中，</span><span lang="EN-US">child-pointer</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">是指向孩子结点的指针，</span><span lang="EN-US">I</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">是覆盖所有孩子结点对应矩形的矩形。这边有点拗口，但我想不是很难懂？给张图：</span></span></p><p class="MsoNormal" style="PADDING-LEFT: 60px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left"><img height="136" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440583IgJP.jpg" width="259">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">D,E,F,G</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为孩子结点所对应的矩形。</span><span lang="EN-US">A</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为能够覆盖这些矩形的更大的矩形。这个</span><span lang="EN-US">A</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">就是这个非叶子结点所对应的矩形。这时候你应该悟到了吧？无论是叶子结点还是非叶子结点，它们都对应着一个矩形。树形结构上层的结点所对应的矩形能够完全覆盖它的孩子结点所对应的矩形。根结点也唯一对应一个矩形，而这个矩形是可以覆盖所有我们拥有的数据信息在空间中代表的点的。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">我个人感觉这张图画的不那么精确，应该是矩形</span><span lang="EN-US">A</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">要恰好覆盖</span><span lang="EN-US">D,E,F,G</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，而不应该再留出这么多没用的空间了。但为尊重原图的绘制者，特不作修改。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><h3><a name="t7" target="_blank"></a><span style="FONT-SIZE: 13px"><span style="mso-bidi-font-weight: normal"><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的操作</span></span></span></h3><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="FONT-SIZE: 13px">这一部分也许是编程者最关注的问题了。这么高效的数据结构该如何去实现呢？这便是这一节需要阐述的问题。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><h4><a name="t8" target="_blank"></a><span style="mso-bidi-font-weight: normal"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><strong>搜索</strong></span></span></span></h4><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的搜索操作很简单，跟</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树上的搜索十分相似。它返回的结果是所有符合查找信息的记录条目。而输入是什么？就我个人的理解，输入不仅仅是一个范围了，它更可以看成是一个空间中的矩形。也就是说，我们输入的是一个搜索矩形。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="FONT-SIZE: 13px">先给出伪代码：</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">Function</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">Search</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">描述：假设</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为一棵</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的根结点，查找所有搜索矩形</span><span lang="EN-US">S</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">覆盖的记录条目。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">S1:[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">查找子树</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">是非叶子结点，如果</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所对应的矩形与</span><span lang="EN-US">S</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">有重合，那么检查所有</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中存储的条目，对于所有这些条目，使用</span><span lang="EN-US">Search</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作作用在每一个条目所指向的子树的根结点上（即</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">结点的孩子结点）。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">S2:[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">查找叶子结点</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">是叶子结点，如果</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所对应的矩形与</span><span lang="EN-US">S</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">有重合，那么直接检查</span><span lang="EN-US">S</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所指向的所有记录条目。返回符合条件的记录。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">我们通过下图来理解这个</span><span lang="EN-US">Search</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作。</span></span></p><p class="MsoNormal" style="PADDING-LEFT: 30px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><img height="344" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440583m707.jpg" width="392"></span></span>&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left">&nbsp;<img height="170" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440582Z061.jpg" width="453"></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">阴影部分所对应的矩形为搜索矩形。它与根结点对应的最大的矩形（未画出）有重叠。这样将</span><span lang="EN-US">Search</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作作用在其两个子树上。两个子树对应的矩形分别为</span><span lang="EN-US">R1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">与</span><span lang="EN-US">R2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。搜索</span><span lang="EN-US">R1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，发现与</span><span lang="EN-US">R1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的</span><span lang="EN-US">R4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">矩形有重叠，继续搜索</span><span lang="EN-US">R4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。最终在</span><span lang="EN-US">R4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所包含的</span><span lang="EN-US">R11</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">与</span><span lang="EN-US">R12</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">两个矩形中查找是否有符合条件的记录。搜索</span><span lang="EN-US">R2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的过程同样如此。很显然，该算法进行的是一个迭代操作。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="mso-bidi-font-weight: normal"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><strong>插入</strong></span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的插入操作也同</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的插入操作类似。当新的数据记录需要被添加入叶子结点时，若叶子结点溢出，那么我们需要对叶子结点进行分裂操作。显然，叶子结点的插入操作会比搜索操作要复杂。插入操作需要一些辅助方法才能够完成。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="FONT-SIZE: 13px">来看一下伪代码：</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="TEXT-DECORATION: underline"><span lang="EN-US">Function</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">Insert</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">描述：将新的记录条目</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">插入给定的</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树中。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">I1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为新记录找到合适插入的叶子结点</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">开始</span><span lang="EN-US">ChooseLeaf</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">方法选择叶子结点</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">以放置记录</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">I2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">添加新记录至叶子结点</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">有足够的空间来放置新的记录条目，则向</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中添加</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。如果没有足够的空间，则进行</span><span lang="EN-US">SplitNode</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">方法以获得两个结点</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">与</span><span lang="EN-US">LL</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，这两个结点包含了所有原来叶子结点</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的条目与新条目</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">I3</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">将变换向上传递</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">开始对结点</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">进行</span><span lang="EN-US">AdjustTree</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作，如果进行了分裂操作，那么同时需要对</span><span lang="EN-US">LL</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">进行</span><span lang="EN-US">AdjustTree</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">I4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">对树进行增高操作</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果结点分裂，且该分裂向上传播导致了根结点的分裂，那么需要创建一个新的根结点，并且让它的两个孩子结点分别为原来那个根结点分裂后的两个结点。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="TEXT-DECORATION: underline"><span lang="EN-US">Function</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">ChooseLeaf</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">描述：选择叶子结点以放置新条目</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">CL1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[Initialize] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">设置</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为根结点。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">CL2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">叶子结点的检查</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为叶子结点，则直接返回</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">CL3</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">选择子树</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">不是叶子结点，则遍历</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的结点，找出添加</span><span lang="EN-US">E.I</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">时扩张最小的结点，并把该结点定义为</span><span lang="EN-US">F</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。如果有多个这样的结点，那么选择面积最小的结点。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">CL4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">下降至叶子结点</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">将</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">设为</span><span lang="EN-US">F</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，从</span><span lang="EN-US">CL2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">开始重复操作。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="TEXT-DECORATION: underline"><span lang="EN-US">Function</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">AdjustTree</span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="FONT-SIZE: 13px">描述：叶子结点的改变向上传递至根结点以改变各个矩阵。在传递变换的过程中可能会产生结点的分裂。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">AT1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">初始化</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">将</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">设为</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">AT2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">检验是否完成</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为根结点，则停止操作。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">AT3</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">调整父结点条目的最小边界矩形</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">设</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的父节点，</span><span lang="EN-US">E<sub>N</sub></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为指向在父节点</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中指向</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的条目。调整</span><span lang="EN-US">EN.I</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">以保证所有在</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的矩形都被恰好包围。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">AT4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">向上传递结点分裂</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">有一个刚刚被分裂产生的结点</span><span lang="EN-US">NN</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，则创建一个指向</span><span lang="EN-US">NN</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的条目</span><span lang="EN-US">E<sub>NN</sub></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。如果</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">有空间来存放</span><span lang="EN-US">E<sub>NN</sub></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，则将</span><span lang="EN-US">E<sub>NN</sub></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">添加到</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中。如果没有，则对</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">进行</span><span lang="EN-US">SplitNode</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作以得到</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">和</span><span lang="EN-US">PP</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span lang="EN-US">AT5</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">升高至下一级</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">等于</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">且发生了分裂，则把</span><span lang="EN-US">NN</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">置为</span><span lang="EN-US">PP</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。从</span><span lang="EN-US">AT2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">开始重复操作。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="FONT-SIZE: 13px">&nbsp;</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="FONT-SIZE: 13px">同样，我们用图来更加直观的理解这个插入操作。</span></span></p><p>&nbsp;</p><p class="MsoNormal" style="PADDING-LEFT: 90px" align="left"><img height="284" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440582wJqQ.jpg" width="332">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><img height="167" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440581fXBx.jpg" width="485"></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left">&nbsp;&nbsp;&nbsp; <span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">我们来通过图分析一下插入操作。现在我们需要插入</span><span lang="EN-US">R21</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">这个矩形。开始时我们进行</span><span lang="EN-US">ChooseLeaf</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作。在根结点中有两个条目，分别为</span><span lang="EN-US">R1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，</span><span lang="EN-US">R2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。其实</span><span lang="EN-US">R1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">已经完全覆盖了</span><span lang="EN-US">R21</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，而若向</span><span lang="EN-US">R2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中添加</span><span lang="EN-US">R21</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，则会使</span><span lang="EN-US">R2.I</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">增大很多。显然我们选择</span><span lang="EN-US">R1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">插入。然后进行下一级的操作。相比于</span><span lang="EN-US">R4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，向</span><span lang="EN-US">R3</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中添加</span><span lang="EN-US">R21</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">会更合适，因为</span><span lang="EN-US">R3</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">覆盖</span><span lang="EN-US">R21</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所需增大的面积相对较小。这样就在</span><span lang="EN-US">R8</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，</span><span lang="EN-US"><span style="font-size: 13px;">R</span>9</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，</span><span lang="EN-US"><span style="font-size: 13px;">R</span>10</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所在的叶子结点中插入</span><span lang="EN-US">R21</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。由于叶子结点没有足够空间，则要进行分裂操作。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">&nbsp;&nbsp;&nbsp; 插入</span></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="FONT-SIZE: 13px">操作如下图所示：</span></span></p><p>&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><img height="159" alt="" src="http://hi.csdn.net/attachment/201106/7/8394323_1307440581AIPa.jpg" width="479"></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">这个插入操作其实类似于第一节中</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的插入操作，这里不再具体介绍，不过想必看过上面的伪代码大家应该也清楚了。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><strong></strong></span></span></span></p><h4><a name="t9" target="_blank"></a><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><strong>删除</strong></span></span></span></h4><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的删除操作与</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的删除操作会有所不同，不过同</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树一样，会涉及到压缩等操作。相信读者看完以下的伪代码之后会有所体会。</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的删除同样是比较复杂的，需要用到一些辅助函数来完成整个操作。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">伪代码如下：</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="TEXT-DECORATION: underline"><span lang="EN-US">Function</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">Delete</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">描述：将一条记录</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">从指定的</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树中删除。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">D1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">找到含有记录的叶子结点</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">使用</span><span lang="EN-US">FindLeaf</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">方法找到包含有记录</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的叶子结点</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。如果搜索失败，则直接终止。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">D2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">删除记录</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">将</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">从</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中删除。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">D3</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">传递记录</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">对</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">使用</span><span lang="EN-US">CondenseTree</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">D4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">缩减树</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">当经过以上调整后，如果根结点只包含有一个孩子结点，则将这个唯一的孩子结点设为根结点。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">&nbsp;</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="TEXT-DECORATION: underline"><span lang="EN-US">Function</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">FindLeaf</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">描述：根结点为</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，期望找到包含有记录</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的叶子结点。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">FL1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">搜索子树</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">不是叶子结点，则检查每一条</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的条目</span><span lang="EN-US">F</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，找出与</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所对应的矩形相重合的</span><span lang="EN-US">F</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">（不必完全覆盖）。对于所有满足条件的</span><span lang="EN-US">F</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，对其指向的孩子结点进行</span><span lang="EN-US">FindLeaf</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作，直到寻找到</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">或者所有条目均以被检查过。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">FL2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">搜索叶子结点以找到记录</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">是叶子结点，那么检查每一个条目是否有</span><span lang="EN-US">E</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">存在，如果有则返回</span><span lang="EN-US">T</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">&nbsp;</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="TEXT-DECORATION: underline"><span lang="EN-US">Function</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">CondenseTree</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">描述：</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为包含有被删除条目的叶子结点。如果</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的条目数过少（小于要求的最小值</span><span lang="EN-US">m</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">），则必须将该叶子结点</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">从树中删除。经过这一删除操作，</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的剩余条目必须重新插入树中。此操作将一直重复直至到达根结点。同样，调整在此修改树的过程所经过的路径上的所有结点对应的矩形大小。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">CT1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">初始化</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">令</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为</span><span lang="EN-US">L</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。初始化一个用于存储被删除结点包含的条目的链表</span><span lang="EN-US">Q</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">CT2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">找到父条目</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为根结点，那么直接跳转至</span><span lang="EN-US">CT6</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。否则令</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为</span><span lang="EN-US">N </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的父结点，令</span><span lang="EN-US">E<sub>N</sub></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">为</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">结点中存储的指向</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的条目。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">CT3</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">删除下溢结点</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">含有条目数少于</span><span lang="EN-US">m</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，则从</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中删除</span><span lang="EN-US">E<sub>N</sub></span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，并把结点</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的条目添加入链表</span><span lang="EN-US">Q</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">CT4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">调整覆盖矩形</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">如果</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">没有被删除，则调整</span><span lang="EN-US">E<sub>N</sub>.I</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">使得其对应矩形能够恰好覆盖</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的所有条目所对应的矩形。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">CT5</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">向上一层结点进行操作</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">令</span><span lang="EN-US">N</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">等于</span><span lang="EN-US">P</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，从</span><span lang="EN-US">CT2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">开始重复操作。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">CT6</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">：</span><span lang="EN-US">[</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">重新插入孤立的条目</span><span lang="EN-US">] </span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所有在</span><span lang="EN-US">Q</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的结点中的条目需要被重新插入。原来属于叶子结点的条目可以使用</span><span lang="EN-US">Insert</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作进行重新插入，而那些属于非叶子结点的条目必须插入删除之前所在层的结点，以确保它们所指向的子树还处于相同的层。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">&nbsp;</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树删除记录过程中的</span><span lang="EN-US">CondenseTree</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作是不同于</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的。我们知道，</span><span lang="EN-US">B</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树删除过程中，如果出现结点的记录数少于半满（即下溢）的情况，则直接把这些记录与其他叶子的记录“融合”，也就是说两个相邻结点合并。然而</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树却是直接重新插入。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">&nbsp;</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">同样，我们用图直观的说明这个操作。</span></p><p class="MsoNormal" style="PADDING-LEFT: 90px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><img height="263" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307512429351R.jpg" width="228"></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><img height="364" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307512428Ii2z.jpg" width="516"></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: center" align="center">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">假设结点最大条目数为</span><span lang="EN-US">4</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，最小条目数为</span><span lang="EN-US">2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。在这张图中，我们的目标是删除记录</span><span lang="EN-US">c</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。首先使用</span><span lang="EN-US">FindLeaf</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作找到</span><span lang="EN-US">c</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所处在的叶子结点的位置</span><span lang="EN-US">——R11</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。当</span><span lang="EN-US">c</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">从</span><span lang="EN-US">R11</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">删除时，</span><span lang="EN-US">R11</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">就只有一条记录了，少于最小条目数</span><span lang="EN-US">2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，出现下溢，此时要调用</span><span lang="EN-US">CondenseTree</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">操作。这样，</span><span lang="EN-US">c</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">被删除，</span><span lang="EN-US">R11</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">剩余的条目</span><span lang="EN-US">——</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">指向记录</span><span lang="EN-US">d</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">的指针</span><span lang="EN-US">——</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">被插入链表</span><span lang="EN-US">Q</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。然后向更高一层的结点进行此操作。这样</span><span lang="EN-US">R12</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">会被插入链表中。原理是一样的，在这里就不再赘述。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span lang="EN-US" style="mso-no-proof: yes"><img height="149" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_13075124166AX3.jpg" width="469"></span></p><p class="MsoNormal" style="PADDING-LEFT: 30px; MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span lang="EN-US" style="mso-no-proof: yes"><img height="398" alt="" src="http://hi.csdn.net/attachment/201106/8/8394323_1307512414AUi3.jpg" width="360"></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-INDENT: 21pt; TEXT-ALIGN: left" align="left"><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">有一点需要解释的是，我们发现这个删除操作向上传递之后，根结点的条目</span><span lang="EN-US">R1</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">也被插入了</span><span lang="EN-US">Q</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中，这样根结点只剩下了</span><span lang="EN-US">R2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">。别着急，重新插入操作会有效的解决这个问题。我们插入</span><span lang="EN-US">R3</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，</span><span lang="EN-US">R12</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，</span><span lang="EN-US">d</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">至它原来所处的层。这样，我们发现根结点只有一个条目了，此时根据</span><span lang="EN-US">Inert</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">中的操作，我们把这个根结点删除，它的孩子结点，即</span><span lang="EN-US">R5</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，</span><span lang="EN-US">R6</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，</span><span lang="EN-US">R7</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">，</span><span lang="EN-US">R3</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">所在的结点被置为根结点。至此，删除操作结束。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US">&nbsp;</span></p><h3><a name="t10" target="_blank"></a><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana"><strong>结语</strong></span></h3><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span lang="EN-US"><span style="mso-tab-count: 1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树是一种能够有效进行高维空间搜索的数据结构，它已经被广泛应用在各种数据库及其相关的应用中。但</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的处理也具有局限性，它的最佳应用范围是处理</span><span lang="EN-US">2</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">至</span><span lang="EN-US">6</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">维的数据，更高维的存储会变得非常复杂，这样就不适用了。近年来，</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树也出现了很多变体，</span><span lang="EN-US">R*</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树就是其中的一种。这些变体提升了</span><span lang="EN-US">R</span><span style="font-family:微软雅黑;mso-ascii-font-family: Verdana">树的性能，感兴趣的读者可以参考相关文献。文章有任何错误，还望各位读者不吝赐教。本文完。</span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left">&nbsp;</p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">参考文献以及推荐阅读：</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">1.<span style="mso-tab-count: 1">&nbsp;&nbsp; </span>Organization and Maintenance of Large Ordered Indices</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="color:black;mso-bidi-font-size: 10.5pt"><span style="FONT-SIZE: 13px">2.<span style="mso-tab-count: 1">&nbsp;&nbsp; </span>the ubiquitous B tree</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">3.<span style="mso-tab-count: 1">&nbsp;&nbsp; </span><a target="_blank" href="http://en.wikipedia.org/wiki/Btree"><span style="color:#002d93;">http://en.wikipedia.org/wiki/Btree</span></a> </span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">（给出了国外一些开源地址）</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">4. &nbsp;</span><span style="color: black; "><span style="font-family:Arial;">&nbsp;<a target="_blank" href="http://en.wikipedia.org/wiki/Btree#Technical_description">http://en.wikipedia.org/wiki/Btree#Technical_description</a></span></span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">5.<span style="mso-tab-count: 1">&nbsp;&nbsp; </span><a target="_blank" href="http://cis.stvincent.edu/html/tutorials/swd/btree/btree.html"><span style="color:#002d93;">http://cis.stvincent.edu/html/tutorials/swd/btree/btree.html</span></a></span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">（</span><span style="color:black;mso-bidi-font-size: 10.5pt">include C++ source code</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">）</span></span></p></div><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="color:black;mso-bidi-font-size: 10.5pt">6.<span style="mso-tab-count: 1">&nbsp;&nbsp; <a target="_blank" href="http://slady.net/java/bt/view.php"><span style="color:#002d93;">http://slady.net/java/bt/view.php</span></a></span></span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">（如果了解了</span><span style="color:black;mso-bidi-font-size: 10.5pt">B-tree</span><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">结构，该地址可以在线对该结构进行查找（search），插入(insert)，删除(delete)操作。）<br>7. Guttman, A.; “R-trees: a dynamic index structure for spatial searching,” ACM, 1984, 14 </span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">8. <a target="_blank" href="http://www.cnblogs.com/CareySon/archive/2012/04/06/2435349.html">http://www.cnblogs.com/CareySon/archive/2012/04/06/2435349.html</a>；</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">9.&nbsp;<a target="_blank" href="http://baike.baidu.com/view/298408.htm">http://baike.baidu.com/view/298408.htm</a>。</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">10.&nbsp;<a target="_blank" href="http://www.cnblogs.com/leoo2sk/archive/2011/07/10/mysql-index.html">http://www.cnblogs.com/leoo2sk/archive/2011/07/10/mysql-index.html</a>&nbsp;（介绍了mysql中myisam和innodb这两种引擎的内部索引机制，以及对不同字段的索引时，检索效率上的对比，主要也是基于其内部机制的理解）</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">11.&nbsp;<a target="_blank" href="http://www.oschina.net/news/31988/mysql-indexing-best-practices">http://www.oschina.net/news/31988/mysql-indexing-best-practices</a>&nbsp;（MySQL 索引最佳实践）；</span></span></p><p class="MsoNormal" style="MARGIN: 0cm 0cm 0pt; TEXT-ALIGN: left" align="left"><span style="FONT-SIZE: 13px"><span style="font-family:微软雅黑;color:black;mso-ascii-font-family: Verdana; mso-bidi-font-size: 10.5pt">12.&nbsp;<a target="_blank" href="http://idlebox.net/2007/stx-btree/">http://idlebox.net/2007/stx-btree/</a>（此页面包含B树生成构造的一些演示demo）。</span></span></p><hr><p><span style="color:#800000;"><strong><span style="FONT-SIZE: 13px">版权所有，侵权必究。本blog内任何内容严禁用于任何商业用途，违者永久追究法律责任。</span></strong></span></p>


&emsp;&nbsp;原文：<a target="_blank" href="http://blog.csdn.net/v_july_v/article/details/6530142">http://blog.csdn.net/v_july_v/article/details/6530142</a>