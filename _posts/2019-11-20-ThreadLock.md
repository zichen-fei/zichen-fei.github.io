---
layout: post
title: Java中的线程安全和锁优化
date: 2019-11-20
tags: JVM
---

**当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，
调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的**

### **线程安全实现方法**

#### **互斥同步**

互斥同步（Mutual Exclusion & Synchronization）是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，
保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用。互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）
和信号量（Semaphore）都是主要的互斥实现方式。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。

在Java中，最基本的互斥同步手段是synchronized关键字，synchronized关键字经过编译之后，
会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。
如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，
那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。

在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，
在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止

除了synchronized之外，还可以使用java.util.concurrent包中的重入锁（ReentrantLock）来实现同步，在基本用法上，
ReentrantLock与synchronized很相似，都具备一样的线程重入特性，只是代码写法上有区别，
一个表现为API层面的互斥锁（lock()和unlock()方法配合try/finally语句块来完成），另一个表现为原生语法层面的互斥锁。

ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断、可实现公平锁，以及锁可以绑定多个条件

+ 等待可中断：指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助

+ 实现公平锁：公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，
任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁

+ 绑定多个条件：指一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，
锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就需要额外地添加一个锁，
而ReentrantLock只需要多次调用newCondition()方法即可。 

#### **非阻塞同步**

基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，
那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，
因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）

乐观并发策略需要“硬件指令集的发展”才能进行，因为操作和冲突检测这两个步骤具备原子性，
硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有

+ 测试并设置（Test-and-Set）

+ 获取并增加（Fetch-and-Increment）

+ 交换（Swap）

+ 比较并交换（Compare-and-Swap）[Java中的CAS](../../../2019/11/JavaCAS/)

+ 加载链接/条件存储（Load-Linked/Store-Conditional）

#### **无同步**

同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，如：

+ 可重入代码：可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。这类代码
具有不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等特征

+ 线程本地存储：如果一段代码中所需要的数据必须与其他代码共享，而且能保证这些共享数据的代码是否能保证在同一个线程中执行，
就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题

### 锁优化

#### **自旋锁与自适应自旋**

互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，频繁的再用户态和内核态之间切换或给系统的并发性能带来了很大的压力，
大部分共享数据的锁定状态只会持续很短的一段时间，如果物理机器有**一个以上的处理器**，能让两个或以上的线程同时并行执行，就可以让后面请求锁的那个线程“稍等一下”，
但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。只需让线程执行一个忙循环（自旋）就可以让线程等待，这项技术就是所谓的自旋锁

自旋等待不能代替阻塞，虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，
反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费，
如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋次数的默认值是10次，用户可以使用参数-XX:PreBlockSpin来更改。

在JDK 1.6中引入了自适应的自旋锁。自旋的时间是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，
自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，
比如100个循环。如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。

#### **锁消除**

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。主要判定依据来源于逃逸分析的数据支持，
如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以当做栈上数据对待（对象也可以再栈上分配），认为线程私有的，就无需同步加锁

[Java中的逃逸分析]()

```
public String concatString(String s1, String s2, String s3) {
  return s1 + s2 + s3;
}
```

这段非常简单的代码仅仅是输出3个字符串相加的结果，无论是源码字面上还是程序语义上都没有同步。

由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此编译器会对String连接做自动优化。
在JDK 1.5之前，会转化为StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，会转化为StringBuilder对象的连续append()操作

```
public String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
```

以上代码中，每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，很快发现它的动态作用域被限制在concatString()方法内部。
也就是说，sb的所有引用永远不会“逃逸”到concatString()方法之外，其他线程无法访问到它，因此，虽然这里有锁，但是可以被安全地消除掉，
在即时编译之后，这段代码就会忽略掉所有的同步而直接执行了

#### **锁粗化**

原则上，在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，
这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，等待锁的线程也能尽快拿到锁。

但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。

如上面的StringBuffer的append()方法就属于这类情况，如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，
以上面代码为例，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次。

#### **轻量级锁**

> 对象头的内存布局：


#### **偏向锁**